/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: public/src/import/public/memory/generic/memory/lib/mss_generic_attribute_setters.H $ */
/*                                                                        */
/* OpenPOWER sbe Project                                                  */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2022,2023                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
// mss_generic_attribute_setters.H
#ifndef MSS_GENERIC_ATTR_SETTERS_H_
#define MSS_GENERIC_ATTR_SETTERS_H_

#include <fapi2.H>
#include <generic/memory/lib/utils/index.H>
#include <generic/memory/lib/utils/c_str.H>



namespace mss
{
namespace attr
{
///
/// @brief ATTR_BAD_DQ_BITMAP setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Bad DQ bitmap from a controller point of view. The data is a 10 byte bitmap for
/// each of 4 possible ranks. The bad DQ data is stored in NVRAM, and it is stored in
/// a special format translated to a DIMM Connector point of view. All of these details
/// are hidden from the user of this attribute.
///
inline fapi2::ReturnCode set_bad_dq_bitmap(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][10])
{
    uint8_t l_value[4][10] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_BAD_DQ_BITMAP, i_target, l_value) );
    memcpy(&l_value, i_array, 40);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_BAD_DQ_BITMAP, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_DIMM_POS_METADATA setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  To get the FAPI_POS to the equivilent of ATTR_POS, we need to normalize the fapi_pos
/// value to the processor (stride across which ever processor we're on) and then add
/// in the delta per processor as ATTR_POS isn't processor relative (delta is the total
/// dimm on a processor)
///
inline fapi2::ReturnCode set_dimm_pos_metadata(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_POS_METADATA, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DRAM_GEN_METADATA setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Created for use by attributes that need this
/// data earlier than eff_config, such as c_str and the hypervisor. Not meant for direct
/// HWP use. This is just an abstraction of any chip specific EFF_DRAM_GEN attribute.
///
inline fapi2::ReturnCode set_dram_gen_metadata(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DRAM_GEN_METADATA, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_TYPE_METADATA setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Created for use by attributes that
/// need this data earlier than eff_config, such as c_str and the hypervisor. Not meant
/// for direct HWP use. This is just an abstraction of any chip specific EFF_DIMM_TYPE
/// attribute.
///
inline fapi2::ReturnCode set_dimm_type_metadata(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_TYPE_METADATA, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_ROW_REPAIR_DATA setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Row Repair Data for a DIMM target. Data for 4 dimm ranks * 32 bits per row repair
/// Each row repair contains: -5 bits: DRAM position (x8: 0-9, x4: 0-19) -3 bits: sub
/// ranks (0-7) -2 bits: bank group (0-3) -3 bits: bank (0-7) -18 bits: row -1 bits:
/// repair validity (0: repair is invalid, 1: repair is valid)
///
inline fapi2::ReturnCode set_row_repair_data(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][4])
{
    uint8_t l_value[4][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ROW_REPAIR_DATA, i_target, l_value) );
    memcpy(&l_value, i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ROW_REPAIR_DATA, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_DRAM_CWL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  CAS Write Latency.
///
inline fapi2::ReturnCode set_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DRAM_CWL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_RDIMM_BUFFER_DELAY setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Delay due to the presence of a buffer, in number of clocks
///
inline fapi2::ReturnCode set_dimm_buffer_delay(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_RDIMM_BUFFER_DELAY, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC0F setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC0F - Command Latency Adder Control Word; Default value - 04. Values
/// Range from 00 to 04. No need to calculate; User can override with desired experimental
/// value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc0f(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC0F, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC0F, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC0F setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC0F - Command Latency Adder Control Word; Default value - 04. Values
/// Range from 00 to 04. No need to calculate; User can override with desired experimental
/// value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc0f(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC0F, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC0F, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_CS_CMD_LATENCY setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value.
///
inline fapi2::ReturnCode set_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_CS_CMD_LATENCY, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_CS_CMD_LATENCY, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_CS_CMD_LATENCY setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value.
///
inline fapi2::ReturnCode set_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_CS_CMD_LATENCY, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_CS_CMD_LATENCY, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_CA_PARITY_LATENCY setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value.
///
inline fapi2::ReturnCode set_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_CA_PARITY_LATENCY, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_CA_PARITY_LATENCY, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_CA_PARITY_LATENCY setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value.
///
inline fapi2::ReturnCode set_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_CA_PARITY_LATENCY, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_CA_PARITY_LATENCY, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC02 setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range
/// from 0-8. No need to calculate; User can override with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC02, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC02, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC02 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range
/// from 0-8. No need to calculate; User can override with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc02(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC02, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC02, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC03 setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default
/// value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 1st Nibble for CS and CA.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC03, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC03, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC03 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default
/// value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 1st Nibble for CS and CA.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc03(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC03, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC03, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC04 setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default
/// value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC04, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC04, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC04 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default
/// value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc04(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC04, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC04, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC05 setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC05 - Clock Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 138, 2nd Nibble for CK.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC05, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC05, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC05 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC05 - Clock Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 138, 2nd Nibble for CK.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc05(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC05, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC05, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC0B setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Operating Voltage VDD and VrefCA Source Control Word; Read from ATTR_MSS_VOLT_VDDR.
/// Default value - 14. Values Range from 00 to 15 decimal. No need to calculate; User
/// can override with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc0b(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC0B, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC0B, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC0B setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Operating Voltage VDD and VrefCA Source Control Word; Read from ATTR_MSS_VOLT_VDDR.
/// Default value - 14. Values Range from 00 to 15 decimal. No need to calculate; User
/// can override with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc0b(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC0B, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC0B, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC1X setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range
/// from 00 to 3F. No need to calculate; User can override with desired experimental
/// value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC1X, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC1X, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC1X setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range
/// from 00 to 3F. No need to calculate; User can override with desired experimental
/// value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc1x(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC1X, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC1X, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC7X setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to
/// FF.No need to calculate. User can override with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc7x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC7X, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC7X, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F0RC7X setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to
/// FF.No need to calculate. User can override with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f0rc7x(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC7X, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F0RC7X, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC00 setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word; Default
/// value - 00. Values Range from 00 to 0F. No need to calculate. User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC00, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC00, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC00 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word; Default
/// value - 00. Values Range from 00 to 0F. No need to calculate. User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc00(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC00, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC00, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC02 setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word; Default
/// value - 00. Values Range from 00 to 0F. No need to calculate; User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC02, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC02, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC02 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word; Default
/// value - 00. Values Range from 00 to 0F. No need to calculate; User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc02(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC02, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC02, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC03 setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word. Default
/// value - 00. Values Range from 00 to 0F. No need to calculate. User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC03, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC03, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC03 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word. Default
/// value - 00. Values Range from 00 to 0F. No need to calculate. User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc03(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC03, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC03, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC04 setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word; Default
/// value - 00. Values Range from 00 to 0F. No need to calculate. User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC04, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC04, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC04 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word; Default
/// value - 00. Values Range from 00 to 0F. No need to calculate. User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc04(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC04, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC04, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC05 setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word. Default
/// value - 00. Values Range from 00 to 0F. No need to calculate. User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC05, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC05, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC05 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] F1RC00: Data Buffer Interface Driver Characteristics Control Word. Default
/// value - 00. Values Range from 00 to 0F. No need to calculate. User can override
/// with desired experimental value.
///
inline fapi2::ReturnCode set_dimm_ddr4_f1rc05(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC05, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC05, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Value for safe mode dram data bus utilization in centi percent (c%). Set to below
/// optimum value/ rate. On a per port basis Also used for emergency mode throttle Used
/// to thermally protect the system in all supported environmental conditions when OCC
/// is not functional Consumer: thermal_init, initfile Default to 2500 c%
///
inline fapi2::ReturnCode set_safemode_dram_databus_util(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint32_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DRAM_ADDRESS_MIRRORING setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Ranks that have address mirroring. This data is derived from SPD or VPD. Note: This
/// is a bit-wise map and muliple ranks can be mirrored.
///
inline fapi2::ReturnCode set_dram_address_mirroring(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DRAM_ADDRESS_MIRRORING, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DRAM_ADDRESS_MIRRORING, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DRAM_ADDRESS_MIRRORING setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Ranks that have address mirroring. This data is derived from SPD or VPD. Note: This
/// is a bit-wise map and muliple ranks can be mirrored.
///
inline fapi2::ReturnCode set_dram_address_mirroring(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DRAM_ADDRESS_MIRRORING, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DRAM_ADDRESS_MIRRORING, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_OCMB_HALF_DIMM_MODE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Indicates whether the OCMB should be run in half DIMM mode or not
///
inline fapi2::ReturnCode set_ocmb_half_dimm_mode(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MSS_OCMB_HALF_DIMM_MODE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  An override that allows the user to control full or half DIMM mode
///
inline fapi2::ReturnCode set_ocmb_half_dimm_mode_override(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_REORDER_QUEUE_SETTING setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Contains the settings for write/read reorder queue
///
inline fapi2::ReturnCode set_reorder_queue_setting(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_REORDER_QUEUE_SETTING, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_2N_MODE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Default value for 2N Mode from Signal Integrity. 0x0 = Invalid Mode, 0x01 = 1N Mode
/// , 0x02 = 2N Mode If value is set to 0x0 this indicate value was never initialized
/// correctly.
///
inline fapi2::ReturnCode set_mem_2n_mode(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_2N_MODE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_IGNORE_PLUG_RULES setter
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Set to YES if you want to ignore the plug rules. Sometimes this is needed in a partial-good
/// configuration or on a test board.
///
inline fapi2::ReturnCode set_ignore_mem_plug_rules(uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_IGNORE_PLUG_RULES, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX setter
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Set to YES if you want to ignore the DIMM size plug rules. Sometimes this maybe
/// required for characterization testing or on a test board.
///
inline fapi2::ReturnCode set_ignore_mem_plug_rules_dimm_size_mix(uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX setter
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Set to YES if you want to ignore the DIMM height plug rules. Sometimes this maybe
/// required for characterization testing or on a test board.
///
inline fapi2::ReturnCode set_ignore_mem_plug_rules_dimm_height_mix(uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_OMI_X4_DEGRADE_ACTION setter
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Selects the settings for Host and Explorer FIRs for when x4 channel degrade occurs.
/// Default: RECOVERABLE (channel degrade will cause recoverable error) Performance
/// team request is to XSTOP when degrade occurs
///
inline fapi2::ReturnCode set_omi_x4_degrade_action(uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_OMI_X4_DEGRADE_ACTION, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_OMI_CRC_DEBUG setter
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Selects the settings for Host and Explorer FIRs for CRC and NACK errors. Default:
/// MASKED
///
inline fapi2::ReturnCode set_omi_crc_debug(uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_OMI_CRC_DEBUG, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_ENABLE_FIR_UNMASKING setter
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Enable FIR Unmasking for HWPs, applies to functions that are specifically referencing
/// this attribute.
///
inline fapi2::ReturnCode set_enable_fir_unmasking(uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ENABLE_FIR_UNMASKING, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), i_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_DQ setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Pull-up slew rate control for DBYTE transmitter. Valid values are 0-255
///
inline fapi2::ReturnCode set_ddr5_tx_slew_rise_dq(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_DQ, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_DQ setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Pull-down slew rate control for DBYTE transmitter. Valid values are 0-255
///
inline fapi2::ReturnCode set_ddr5_tx_slew_fall_dq(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_DQ, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  [Channel] Pull-up slew rate control for CAC transmitters. Valid values are 0-255
///
inline fapi2::ReturnCode set_ddr5_tx_slew_rise_ac(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_AC, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  [Channel] Pull-down slew rate control for CAC transmitters. Valid values are 0-255
///
inline fapi2::ReturnCode set_ddr5_tx_slew_fall_ac(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_AC, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  [Channel] Pull-up slew rate control for clock. Valid values are 0-255
///
inline fapi2::ReturnCode set_ddr5_tx_slew_rise_ck(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_TX_SLEW_RISE_CK, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_CK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Pull-down slew rate control for clock. Valid values are 0-255
///
inline fapi2::ReturnCode set_ddr5_tx_slew_fall_ck(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_TX_SLEW_FALL_CK, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Control the length of DDR5 write DQ preamble for U0 EnTxDqPreamblePatternU0 in phyinit
/// struct
///
inline fapi2::ReturnCode set_ddr5_en_tx_dq_preamble_pattern_u0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Control the length of DDR5 write DQ preamble for U1 EnTxDqPreamblePatternU1 in phyinit
/// struct
///
inline fapi2::ReturnCode set_ddr5_en_tx_dq_preamble_pattern_u1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_EN_TX_DQ_PREAMBLE_PATTERN_U1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_EN_TX_DM_PREAMBLE_PATTERN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Control the length of DDR5 write DM preamble EnTxDmPreamblePattern in phyinit struct
///
inline fapi2::ReturnCode set_ddr5_en_tx_dm_preamble_pattern(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_EN_TX_DM_PREAMBLE_PATTERN, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Control the pattern of DDR5 write DQ preamble for U0 TxDqPreamblePatternU0 in phyinit
/// struct
///
inline fapi2::ReturnCode set_ddr5_tx_dq_preamble_pattern_u0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Control the pattern of DDR5 write DQ preamble for U1 TxDqPreamblePatternU1 in phyinit
/// struct
///
inline fapi2::ReturnCode set_ddr5_tx_dq_preamble_pattern_u1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_TX_DQ_PREAMBLE_PATTERN_U1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_TX_DM_PREAMBLE_PATTERN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Control the pattern of DDR5 write DM preamble TxDmPreamblePattern in phyinit struct
///
inline fapi2::ReturnCode set_ddr5_tx_dm_preamble_pattern(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_TX_DM_PREAMBLE_PATTERN, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REDUNDANT_CS_EN setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Rank0 DRAM will be half driven by CS0 and CS2. Rank1 DRAM will be half driven by
/// CS1 and CS3.
///
inline fapi2::ReturnCode set_ddr5_redundant_cs_en(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REDUNDANT_CS_EN, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_REDUNDANT_CS_EN, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REDUNDANT_CS_EN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Rank0 DRAM will be half driven by CS0 and CS2. Rank1 DRAM will be half driven by
/// CS1 and CS3.
///
inline fapi2::ReturnCode set_ddr5_redundant_cs_en(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REDUNDANT_CS_EN, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_REDUNDANT_CS_EN, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_RXEN_ADJ setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Offset to apply at the end of RxEn training (in fine steps). Signed value: if bit
/// 0 == '1' value is negative
///
inline fapi2::ReturnCode set_ddr5_rxen_adj(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_RXEN_ADJ, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_WL_ADJ_START setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Offset to apply before internal WL (in fine steps). WL_ADJ_START is subtracted from
/// the TxDqsDly value found after external WL, to be used as the starting point for
/// internal WL.
///
inline fapi2::ReturnCode set_ddr5_wl_adj_start(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_WL_ADJ_START, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_WL_ADJ_END setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Offset to apply after internal WL (in fine steps). WL_ADJ_END is added to the TxDqsDly
/// value found after internal WL, to be used as the final value.
///
inline fapi2::ReturnCode set_ddr5_wl_adj_end(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_WL_ADJ_END, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_PHY_VREF_RD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Vref level to be used by the PHY during reads for DDR5. The units of this field
/// are a percentage of VDDQ according to the following equation: Receiver Vref = VDDQ*PhyVref[6:0]/128.
/// For example to set Vref at 0.25*VDDQ, set this field to 0x20.
///
inline fapi2::ReturnCode set_ddr5_phy_vref_rd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_PHY_VREF_RD, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_RTT_PARK_RD setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  RTT_PARK setting for read accesses. Bits[4:6] bitmap setting for non-target ranks
/// 3 to 0, respectively (bit 7 is not used). If a bit is set, corresponding ranks use
/// RTT_PARK during Reads to this rank; otherwise, RTT_NOM_RD is used. ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_rtt_park_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DDR5_RTT_PARK_RD, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_RTT_PARK_RD, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_RTT_PARK_RD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  RTT_PARK setting for read accesses. Bits[4:6] bitmap setting for non-target ranks
/// 3 to 0, respectively (bit 7 is not used). If a bit is set, corresponding ranks use
/// RTT_PARK during Reads to this rank; otherwise, RTT_NOM_RD is used. ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_rtt_park_rd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DDR5_RTT_PARK_RD, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_RTT_PARK_RD, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_RTT_PARK_WR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  RTT_PARK setting for write accesses. Bits[4:6] bitmap setting for non-target ranks
/// 3 to 0, respectively (bit 7 is not used). If a bit is set, corresponding ranks use
/// RTT_PARK during Writes to this rank; otherwise, RTT_NOM_RD is used. ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_rtt_park_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DDR5_RTT_PARK_WR, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_RTT_PARK_WR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_RTT_PARK_WR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  RTT_PARK setting for write accesses. Bits[4:6] bitmap setting for non-target ranks
/// 3 to 0, respectively (bit 7 is not used). If a bit is set, corresponding ranks use
/// RTT_PARK during Writes to this rank; otherwise, RTT_NOM_RD is used. ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_rtt_park_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DDR5_RTT_PARK_WR, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_RTT_PARK_WR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_SPD_CL_SUPPORTED setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint64_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Cas Latency Supported by DDR5 DRAM
///
inline fapi2::ReturnCode set_ddr5_spd_cl_supported(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint64_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_SPD_CL_SUPPORTED, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_CHB_ACTIVE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Used when the DFI1 channel exists 0 not active 1 active
///
inline fapi2::ReturnCode set_ddr5_chb_active(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_CHB_ACTIVE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Byte 235 - Bus Width for Channels A and B ARRAY[CHANNEL]
///
inline fapi2::ReturnCode set_ddr5_channel_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_CHANNEL_BUS_WIDTH, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MIN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Low bound of the Vref sweep range used during VrefCS training
///
inline fapi2::ReturnCode set_ddr5_vrefcs_sweep_min(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MIN, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MAX setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  High bound of the Vref sweep range used during VrefCS training. The max value is
/// not included in the sweep
///
inline fapi2::ReturnCode set_ddr5_vrefcs_sweep_max(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_VREFCS_SWEEP_MAX, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MIN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Low bound of the Vref sweep range used during VrefCA training
///
inline fapi2::ReturnCode set_ddr5_vrefca_sweep_min(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MIN, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MAX setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  High bound of the Vref sweep range used during VrefCA training. The max value is
/// not included in the sweep
///
inline fapi2::ReturnCode set_ddr5_vrefca_sweep_max(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_VREFCA_SWEEP_MAX, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW00_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Command Address Rate and SDR Modes for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw00_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW00_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW01_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Parity, CMD Blocking, and Alert for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw01_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW01_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW05_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Operating Speed, Vdd Operating voltage and frequency context for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw05_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW05_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW08_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Clock Driver Enable for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw08_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW08_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW09_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Output Address and Control Enable for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw09_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW09_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0A_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for QCK Signal Driver Characteristics for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0a_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0A_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0C_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute QxCA and QxCS Signal Driver Characteristics for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0c_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0C_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0D_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Data Buffer Interface Driver Characteristics for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0d_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0D_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0E_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for QCK, QCA and QCS Output Slew Rate for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0e_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0E_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0F_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for BCK, BCOM and BCS Output Slew Rate for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0f_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0F_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW40_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw40_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW40_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW41_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw41_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW41_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW42_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw42_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW42_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW43_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw43_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW43_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW44_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw44_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW44_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW45_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw45_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW45_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW46_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw46_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW46_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW47_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw47_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW47_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW48_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCS for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw48_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW48_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW49_CHA_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCS for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw49_cha_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW49_CHA_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW00_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Command Address Rate and SDR Modes for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw00_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW00_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW01_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Parity, CMD Blocking, and Alert for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw01_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW01_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW05_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Operating Speed, Vdd Operating voltage and frequency context for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw05_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW05_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW08_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Clock Driver Enable for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw08_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW08_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW09_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Output Address and Control Enable for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw09_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW09_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0A_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for QCK Signal Driver Characteristics for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0a_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0A_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0C_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute QxCA and QxCS Signal Driver Characteristics for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0c_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0C_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0D_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Data Buffer Interface Driver Characteristics for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0d_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0D_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0E_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for QCK, QCA and QCS Output Slew Rate for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0e_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0E_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0F_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for BCK, BCOM and BCS Output Slew Rate for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0f_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0F_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW40_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw40_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW40_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW41_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw41_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW41_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW42_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw42_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW42_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW43_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw43_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW43_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW44_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw44_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW44_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW45_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw45_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW45_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW46_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw46_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW46_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW47_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw47_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW47_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW48_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCS for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw48_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW48_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW49_CHA_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCS for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw49_cha_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW49_CHA_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW00_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Command Address Rate and SDR Modes for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw00_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW00_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW01_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Parity, CMD Blocking, and Alert for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw01_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW01_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW05_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Operating Speed, Vdd Operating voltage and frequency context for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw05_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW05_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW08_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Clock Driver Enable for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw08_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW08_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW09_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Output Address and Control Enable for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw09_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW09_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0A_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for QCK Signal Driver Characteristics for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0a_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0A_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0C_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute QxCA and QxCS Signal Driver Characteristics for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0c_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0C_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0D_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Data Buffer Interface Driver Characteristics for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0d_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0D_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0E_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for QCK, QCA and QCS Output Slew Rate for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0e_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0E_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0F_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for BCK, BCOM and BCS Output Slew Rate for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw0f_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0F_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW40_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw40_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW40_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW41_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw41_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW41_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW42_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw42_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW42_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW43_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw43_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW43_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW44_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw44_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW44_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW45_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw45_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW45_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW46_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw46_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW46_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW47_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw47_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW47_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW48_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCS for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw48_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW48_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW49_CHB_D0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCS for DIMM0
///
inline fapi2::ReturnCode set_ddr5_rcw49_chb_d0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW49_CHB_D0, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW00_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Command Address Rate and SDR Modes for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw00_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW00_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW01_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Parity, CMD Blocking, and Alert for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw01_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW01_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW05_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Operating Speed, Vdd Operating voltage and frequency context for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw05_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW05_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW08_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Clock Driver Enable for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw08_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW08_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW09_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Output Address and Control Enable for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw09_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW09_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0A_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for QCK Signal Driver Characteristics for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0a_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0A_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0C_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute QxCA and QxCS Signal Driver Characteristics for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0c_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0C_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0D_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Data Buffer Interface Driver Characteristics for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0d_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0D_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0E_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for QCK, QCA and QCS Output Slew Rate for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0e_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0E_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW0F_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for BCK, BCOM and BCS Output Slew Rate for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw0f_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW0F_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW40_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw40_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW40_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW41_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw41_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW41_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW42_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw42_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW42_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW43_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw43_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW43_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW44_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw44_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW44_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW45_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw45_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW45_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW46_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw46_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW46_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW47_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCA for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw47_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW47_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW48_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCS for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw48_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW48_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_RCW49_CHB_D1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Attribute for Internal VrefCS for DIMM1
///
inline fapi2::ReturnCode set_ddr5_rcw49_chb_d1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_RCW49_CHB_D1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_EFF_DDR5_MEM_PORT_ENABLE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Byte 235 - Enabled Phys and channels is based on mem ports per ocmb target
///
inline fapi2::ReturnCode set_ddr5_mem_port_enable(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DDR5_MEM_PORT_ENABLE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_BURST_LENGTH setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM burst length Note: OTF in the enums stands for On The Fly. Acronym is used
/// to correspond with JEDEC
///
inline fapi2::ReturnCode set_burst_length(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_BURST_LENGTH, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_MPSM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Max Power Saving Mode
///
inline fapi2::ReturnCode set_mpsm(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_MPSM, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_CS_ASSERT_IN_MPC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Chip Select assertion mode for MPC commands
///
inline fapi2::ReturnCode set_cs_assert_in_mpc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_CS_ASSERT_IN_MPC, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DEVICE15_MPSM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Setting for device 15's Max Power Saving Mode
///
inline fapi2::ReturnCode set_device15_mpsm(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DEVICE15_MPSM, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_INTERNAL_WR_TIMING_MODE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM setting to enable or disable internal WR timing offsets
///
inline fapi2::ReturnCode set_internal_wr_timing_mode(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_INTERNAL_WR_TIMING_MODE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Internal WR cycle alignment 0 -> 0 tck 0xf -> -15 tck Includes values on a per-Rank,
/// per-DRAM (nibble) ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_wl_internal_cycle_alignment(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][20])
{
    uint8_t l_value[2][4][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 80);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Internal WR cycle alignment 0 -> 0 tck 0xf -> -15 tck Includes values on a per-Rank,
/// per-DRAM (nibble) ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_wl_internal_cycle_alignment(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][20])
{
    uint8_t l_value[2][4][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT, i_target, l_value) );
    memcpy(&l_value, i_array, 160);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_WL_INTERNAL_CYCLE_ALIGNMENT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_REF_INTERVAL_RATE_INDIC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Refresh rate indicator
///
inline fapi2::ReturnCode set_ref_rate_indic(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_REF_INTERVAL_RATE_INDIC, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_MIN_REF_RATE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum refresh rate supported. Decodings are noted in the DDR5 spec
///
inline fapi2::ReturnCode set_ddr5_min_ref_rate(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_MIN_REF_RATE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_REF_WIDE_RANGE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Indicates refresh wide range support
///
inline fapi2::ReturnCode set_ddr5_ref_wide_range(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_REF_WIDE_RANGE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_REF_TUF setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 temperature update flag
///
inline fapi2::ReturnCode set_ddr5_ref_tuf(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_REF_TUF, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DRAM_PU_DRV_IMP setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM pull up drive impedance ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_dram_pu_drv_imp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DRAM_PU_DRV_IMP, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DRAM_PU_DRV_IMP, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DRAM_PU_DRV_IMP setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM pull up drive impedance ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_dram_pu_drv_imp(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DRAM_PU_DRV_IMP, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DRAM_PU_DRV_IMP, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_TEST_MODE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Notes if the DRAM supports test mode
///
inline fapi2::ReturnCode set_ddr5_dram_test_mode(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_TEST_MODE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DRAM_PD_DRV_IMP setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM pull down drive impedance ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_dram_pd_drv_imp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DRAM_PD_DRV_IMP, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DRAM_PD_DRV_IMP, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DRAM_PD_DRV_IMP setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM pull down drive impedance ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_dram_pd_drv_imp(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DRAM_PD_DRV_IMP, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DRAM_PD_DRV_IMP, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RD_PREAMBLE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  RD Preamble settings
///
inline fapi2::ReturnCode set_ddr5_dram_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RD_PREAMBLE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_WR_PREAMBLE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  WR Preamble settings
///
inline fapi2::ReturnCode set_ddr5_dram_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_WR_PREAMBLE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RD_POSTAMBLE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  RD Postamble settings
///
inline fapi2::ReturnCode set_ddr5_dram_rd_postamble(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RD_POSTAMBLE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_WR_POSTAMBLE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  WR Postamble settings
///
inline fapi2::ReturnCode set_ddr5_dram_wr_postamble(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_WR_POSTAMBLE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_WR_VREFDQ setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM WR VREF DQ value. Decodes are noted in MR10 in the DDR5 JEDEC spec ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_wr_vrefdq(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][20])
{
    uint8_t l_value[2][4][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_WR_VREFDQ, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 80);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_WR_VREFDQ, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_WR_VREFDQ setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM WR VREF DQ value. Decodes are noted in MR10 in the DDR5 JEDEC spec ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_wr_vrefdq(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][20])
{
    uint8_t l_value[2][4][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_WR_VREFDQ, i_target, l_value) );
    memcpy(&l_value, i_array, 160);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_WR_VREFDQ, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_VREFCA setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM VREF CA value. Decodes are noted in MR11 in the DDR5 JEDEC spec ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_vrefca(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][20])
{
    uint8_t l_value[2][4][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_VREFCA, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 80);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_VREFCA, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_VREFCA setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM VREF CA value. Decodes are noted in MR11 in the DDR5 JEDEC spec ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_vrefca(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][20])
{
    uint8_t l_value[2][4][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_VREFCA, i_target, l_value) );
    memcpy(&l_value, i_array, 160);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_VREFCA, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_VREFCS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM VREF CS value. Decodes are noted in MR11 in the DDR5 JEDEC spec ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_vrefcs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][20])
{
    uint8_t l_value[2][4][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_VREFCS, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 80);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_VREFCS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_VREFCS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM VREF CS value. Decodes are noted in MR11 in the DDR5 JEDEC spec ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_vrefcs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][20])
{
    uint8_t l_value[2][4][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_VREFCS, i_target, l_value) );
    memcpy(&l_value, i_array, 160);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_VREFCS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ECS_MODE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Error Check Scrub operation mode
///
inline fapi2::ReturnCode set_ddr5_dram_ecs_mode(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ECS_MODE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ECS_RESET_COUNTER setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Error Check Scrub reset counter mode
///
inline fapi2::ReturnCode set_ddr5_dram_ecs_reset_counter(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ECS_RESET_COUNTER, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ECS_COUNT_MODE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Error Check Scrub count mode: Rows or Code words
///
inline fapi2::ReturnCode set_ddr5_dram_ecs_count_mode(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ECS_COUNT_MODE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ECS_SRANK_SELECT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Error Check Scrub which rank to select. Should be 0 for non-3DS parts
///
inline fapi2::ReturnCode set_ddr5_dram_ecs_srank_select(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ECS_SRANK_SELECT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ECS_THRESHOLD_COUNT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Error Check Scrub Error Threshold Count
///
inline fapi2::ReturnCode set_ddr5_dram_ecs_threshold_count(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ECS_THRESHOLD_COUNT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ECS_IN_SELF_REFRESH setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Error Check Scrub mode while in self refresh
///
inline fapi2::ReturnCode set_ddr5_dram_ecs_in_self_refresh(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ECS_IN_SELF_REFRESH, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ECS_WRITEBACK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Error Check Scrub writeback mode: allowed or suppressed
///
inline fapi2::ReturnCode set_ddr5_dram_ecs_writeback(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ECS_WRITEBACK, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ECS_X4_WRITES setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Error Check Scrub RMW mode
///
inline fapi2::ReturnCode set_ddr5_dram_ecs_x4_writes(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ECS_X4_WRITES, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CK_ODT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 clock ODT value. ARRAY[DIMM][RANK][STRAP]
///
inline fapi2::ReturnCode set_ddr5_dram_ck_odt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t (&i_array)[4][2])
{
    uint16_t l_value[2][4][2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CK_ODT, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CK_ODT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CK_ODT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 clock ODT value. ARRAY[DIMM][RANK][STRAP]
///
inline fapi2::ReturnCode set_ddr5_dram_ck_odt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2][4][2])
{
    uint16_t l_value[2][4][2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CK_ODT, i_target, l_value) );
    memcpy(&l_value, i_array, 32);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CK_ODT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CS_ODT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 chip select ODT value. ARRAY[DIMM][RANK][STRAP]
///
inline fapi2::ReturnCode set_ddr5_dram_cs_odt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t (&i_array)[4][2])
{
    uint16_t l_value[2][4][2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CS_ODT, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CS_ODT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CS_ODT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 chip select ODT value. ARRAY[DIMM][RANK][STRAP]
///
inline fapi2::ReturnCode set_ddr5_dram_cs_odt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2][4][2])
{
    uint16_t l_value[2][4][2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CS_ODT, i_target, l_value) );
    memcpy(&l_value, i_array, 32);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CS_ODT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CK_ODT_PER_DRAM setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 clock ODT value. ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_ck_odt_per_dram(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t (&i_array)[4][20])
{
    uint16_t l_value[2][4][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CK_ODT_PER_DRAM, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 160);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CK_ODT_PER_DRAM, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CK_ODT_PER_DRAM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 clock ODT value. ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_ck_odt_per_dram(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2][4][20])
{
    uint16_t l_value[2][4][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CK_ODT_PER_DRAM, i_target, l_value) );
    memcpy(&l_value, i_array, 320);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CK_ODT_PER_DRAM, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CS_ODT_PER_DRAM setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 chip select ODT value. ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_cs_odt_per_dram(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t (&i_array)[4][20])
{
    uint16_t l_value[2][4][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CS_ODT_PER_DRAM, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 160);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CS_ODT_PER_DRAM, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CS_ODT_PER_DRAM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 chip select ODT value. ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_cs_odt_per_dram(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2][4][20])
{
    uint16_t l_value[2][4][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CS_ODT_PER_DRAM, i_target, l_value) );
    memcpy(&l_value, i_array, 320);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CS_ODT_PER_DRAM, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CA_ODT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 clock ODT value. ARRAY[DIMM][RANK][STRAP]
///
inline fapi2::ReturnCode set_ddr5_dram_ca_odt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t (&i_array)[4][2])
{
    uint16_t l_value[2][4][2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CA_ODT, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CA_ODT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CA_ODT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 clock ODT value. ARRAY[DIMM][RANK][STRAP]
///
inline fapi2::ReturnCode set_ddr5_dram_ca_odt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2][4][2])
{
    uint16_t l_value[2][4][2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CA_ODT, i_target, l_value) );
    memcpy(&l_value, i_array, 32);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CA_ODT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_DQS_RTT_PARK setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM DQS RTT Park Termination Resistance in Ohms. ARRAY[DIMM][RANK][STRAP]
///
inline fapi2::ReturnCode set_ddr5_dram_dqs_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][2])
{
    uint8_t l_value[2][4][2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_DQS_RTT_PARK, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_DQS_RTT_PARK, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_DQS_RTT_PARK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM DQS RTT Park Termination Resistance in Ohms. ARRAY[DIMM][RANK][STRAP]
///
inline fapi2::ReturnCode set_ddr5_dram_dqs_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][2])
{
    uint8_t l_value[2][4][2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_DQS_RTT_PARK, i_target, l_value) );
    memcpy(&l_value, i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_DQS_RTT_PARK, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CA_ODT_PER_DRAM setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 clock ODT value. ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_ca_odt_per_dram(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t (&i_array)[4][20])
{
    uint16_t l_value[2][4][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CA_ODT_PER_DRAM, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 160);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CA_ODT_PER_DRAM, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_CA_ODT_PER_DRAM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 clock ODT value. ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_ca_odt_per_dram(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2][4][20])
{
    uint16_t l_value[2][4][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_CA_ODT_PER_DRAM, i_target, l_value) );
    memcpy(&l_value, i_array, 320);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_CA_ODT_PER_DRAM, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM DQS RTT Park Termination Resistance in Ohms. ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_dqs_rtt_park_per_dram(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][20])
{
    uint8_t l_value[2][4][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 80);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM DQS RTT Park Termination Resistance in Ohms. ARRAY[DIMM][RANK][DRAM]
///
inline fapi2::ReturnCode set_ddr5_dram_dqs_rtt_park_per_dram(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][20])
{
    uint8_t l_value[2][4][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM, i_target, l_value) );
    memcpy(&l_value, i_array, 160);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_DQS_RTT_PARK_PER_DRAM, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RTT_WR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM RTT PARK for writes Termination Resistance in Ohms. ARRAY[DIMM][RANK][CHANNEL]
///
inline fapi2::ReturnCode set_ddr5_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][2])
{
    uint8_t l_value[2][4][2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_RTT_WR, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RTT_WR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RTT_WR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM RTT PARK for writes Termination Resistance in Ohms. ARRAY[DIMM][RANK][CHANNEL]
///
inline fapi2::ReturnCode set_ddr5_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][2])
{
    uint8_t l_value[2][4][2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_RTT_WR, i_target, l_value) );
    memcpy(&l_value, i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RTT_WR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RTT_PARK setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM RTT PARK for reads Termination Resistance in Ohms. ARRAY[DIMM][RANK][CHANNEL]
///
inline fapi2::ReturnCode set_ddr5_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][2])
{
    uint8_t l_value[2][4][2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_RTT_PARK, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RTT_PARK, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RTT_PARK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM RTT PARK for reads Termination Resistance in Ohms. ARRAY[DIMM][RANK][CHANNEL]
///
inline fapi2::ReturnCode set_ddr5_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][2])
{
    uint8_t l_value[2][4][2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_RTT_PARK, i_target, l_value) );
    memcpy(&l_value, i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RTT_PARK, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RTT_NOM_WR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM RTT NOM for writes Termination Resistance in Ohms. ARRAY[DIMM][RANK][CHANNEL]
///
inline fapi2::ReturnCode set_ddr5_dram_rtt_nom_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][2])
{
    uint8_t l_value[2][4][2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_RTT_NOM_WR, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RTT_NOM_WR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RTT_NOM_WR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM RTT NOM for writes Termination Resistance in Ohms. ARRAY[DIMM][RANK][CHANNEL]
///
inline fapi2::ReturnCode set_ddr5_dram_rtt_nom_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][2])
{
    uint8_t l_value[2][4][2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_RTT_NOM_WR, i_target, l_value) );
    memcpy(&l_value, i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RTT_NOM_WR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RTT_NOM_RD setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM RTT NOM for reads Termination Resistance in Ohms. ARRAY[DIMM][RANK][CHANNEL]
///
inline fapi2::ReturnCode set_ddr5_dram_rtt_nom_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4][2])
{
    uint8_t l_value[2][4][2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_RTT_NOM_RD, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RTT_NOM_RD, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_RTT_NOM_RD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM RTT NOM for reads Termination Resistance in Ohms. ARRAY[DIMM][RANK][CHANNEL]
///
inline fapi2::ReturnCode set_ddr5_dram_rtt_nom_rd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4][2])
{
    uint8_t l_value[2][4][2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_RTT_NOM_RD, i_target, l_value) );
    memcpy(&l_value, i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_RTT_NOM_RD, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLON_WR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODTon timing for writes ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtlon_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        int8_t (&i_array)[4])
{
    int8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLON_WR, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLON_WR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLON_WR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODTon timing for writes ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtlon_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        int8_t (&i_array)[2][4])
{
    int8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLON_WR, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLON_WR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLOFF_WR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODToff timing for writes ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtloff_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        int8_t (&i_array)[4])
{
    int8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_WR, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_WR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLOFF_WR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODToff timing for writes ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtloff_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        int8_t (&i_array)[2][4])
{
    int8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_WR, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_WR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLON_WR_NT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODTon non-targetted termination timing for writes ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtlon_wr_nt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        int8_t (&i_array)[4])
{
    int8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLON_WR_NT, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLON_WR_NT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLON_WR_NT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODTon non-targetted termination timing for writes ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtlon_wr_nt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        int8_t (&i_array)[2][4])
{
    int8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLON_WR_NT, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLON_WR_NT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLOFF_WR_NT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODToff non-targetted termination timing for writes ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtloff_wr_nt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        int8_t (&i_array)[4])
{
    int8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_WR_NT, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_WR_NT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLOFF_WR_NT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODToff non-targetted termination timing for writes ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtloff_wr_nt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        int8_t (&i_array)[2][4])
{
    int8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_WR_NT, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_WR_NT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLON_RD_NT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODTon non-targetted termination timing for read ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtlon_rd_nt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        int8_t (&i_array)[4])
{
    int8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLON_RD_NT, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLON_RD_NT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLON_RD_NT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODTon non-targetted termination timing for read ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtlon_rd_nt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        int8_t (&i_array)[2][4])
{
    int8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLON_RD_NT, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLON_RD_NT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLOFF_RD_NT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODToff non-targetted termination timing for read ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtloff_rd_nt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        int8_t (&i_array)[4])
{
    int8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_RD_NT, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_RD_NT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_DDR5_DRAM_ODTLOFF_RD_NT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] int8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM ODToff non-targetted termination timing for read ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dram_odtloff_rd_nt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        int8_t (&i_array)[2][4])
{
    int8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_RD_NT, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_DDR5_DRAM_ODTLOFF_RD_NT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_WR_CRC_ERR_STATUS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM's Write CRC error status
///
inline fapi2::ReturnCode set_ddr5_wr_crc_err_status(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_WR_CRC_ERR_STATUS, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM's Write CRC auto-disable enable
///
inline fapi2::ReturnCode set_ddr5_wr_crc_autodisable_enable(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_ENABLE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_STATUS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM's Write CRC auto-disable status
///
inline fapi2::ReturnCode set_ddr5_wr_crc_autodisable_status(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_STATUS, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM's Write CRC auto-disable threshold
///
inline fapi2::ReturnCode set_ddr5_wr_crc_autodisable_threshold(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_THRESHOLD, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DRAM's Write CRC auto-disable window
///
inline fapi2::ReturnCode set_ddr5_wr_crc_autodisable_window(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_WR_CRC_AUTODISABLE_WINDOW, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_GLOBAL_DFE_GAIN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DFE Gain enable/disable
///
inline fapi2::ReturnCode set_ddr5_global_dfe_gain(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_GLOBAL_DFE_GAIN, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_GLOBAL_DFE_TAP1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DFE TAP-1 enable/disable
///
inline fapi2::ReturnCode set_ddr5_global_dfe_tap1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_GLOBAL_DFE_TAP1, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_GLOBAL_DFE_TAP2 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DFE TAP-2 enable/disable
///
inline fapi2::ReturnCode set_ddr5_global_dfe_tap2(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_GLOBAL_DFE_TAP2, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_GLOBAL_DFE_TAP3 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DFE TAP-3 enable/disable
///
inline fapi2::ReturnCode set_ddr5_global_dfe_tap3(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_GLOBAL_DFE_TAP3, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_GLOBAL_DFE_TAP4 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DFE TAP-4 enable/disable
///
inline fapi2::ReturnCode set_ddr5_global_dfe_tap4(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_GLOBAL_DFE_TAP4, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_DFE_GAIN_BIAS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DFE gain bias ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dfe_gain_bias(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DDR5_DFE_GAIN_BIAS, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_DFE_GAIN_BIAS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_DFE_GAIN_BIAS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DFE gain bias ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dfe_gain_bias(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DDR5_DFE_GAIN_BIAS, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_DFE_GAIN_BIAS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_DFE_SIGN_BIT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DFE sign bit ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dfe_sign_bit(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DDR5_DFE_SIGN_BIT, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_DFE_SIGN_BIT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DDR5_DFE_SIGN_BIT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR5 DFE sign bit ARRAY[DIMM][RANK]
///
inline fapi2::ReturnCode set_ddr5_dfe_sign_bit(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DDR5_DFE_SIGN_BIT, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DDR5_DFE_SIGN_BIT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_EFF_DRAM_GEN setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4,
/// DDR5
///
inline fapi2::ReturnCode set_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_GEN, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_GEN, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_GEN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4,
/// DDR5
///
inline fapi2::ReturnCode set_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_GEN, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_GEN, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM,
/// UDIMM, LRDIMM as specified by the JEDEC standard.
///
inline fapi2::ReturnCode set_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_TYPE, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_TYPE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM,
/// UDIMM, LRDIMM as specified by the JEDEC standard.
///
inline fapi2::ReturnCode set_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                       uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_TYPE, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_TYPE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HYBRID_MEMORY_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Hybrid Media. Decodes SPD Byte 3 (bits 6~4)
///
inline fapi2::ReturnCode set_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HYBRID_MEMORY_TYPE, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_HYBRID_MEMORY_TYPE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HYBRID_MEMORY_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Hybrid Media. Decodes SPD Byte 3 (bits 6~4)
///
inline fapi2::ReturnCode set_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HYBRID_MEMORY_TYPE, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_HYBRID_MEMORY_TYPE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HYBRID setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Hybrid. Decodes SPD Byte 3 (bit 7)
///
inline fapi2::ReturnCode set_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HYBRID, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_HYBRID, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HYBRID setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Hybrid. Decodes SPD Byte 3 (bit 7)
///
inline fapi2::ReturnCode set_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HYBRID, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_HYBRID, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] OMI to DDR frequency ratio
///
inline fapi2::ReturnCode set_host_to_ddr_speed_ratio(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] OMI to DDR frequency ratio
///
inline fapi2::ReturnCode set_host_to_ddr_speed_ratio(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_DENSITY setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per
/// die. For multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each
/// DRAM die in the stack.
///
inline fapi2::ReturnCode set_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_DENSITY, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_DENSITY, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_DENSITY setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per
/// die. For multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each
/// DRAM die in the stack.
///
inline fapi2::ReturnCode set_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_DENSITY, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_DENSITY, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_BANK_BITS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Number of DRAM bank address bits. Actual number of banks is 2^N, where
/// N is the number of bank address bits. Decodes SPD Byte 4 (bits 5~4).
///
inline fapi2::ReturnCode set_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_BANK_BITS, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_BANK_BITS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_BANK_BITS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Number of DRAM bank address bits. Actual number of banks is 2^N, where
/// N is the number of bank address bits. Decodes SPD Byte 4 (bits 5~4).
///
inline fapi2::ReturnCode set_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_BANK_BITS, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_BANK_BITS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank
/// groups is 2^N, where N is the number of bank address bits. This value represents
/// the number of bank groups into which the memory array is divided.
///
inline fapi2::ReturnCode set_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank
/// groups is 2^N, where N is the number of bank address bits. This value represents
/// the number of bank groups into which the memory array is divided.
///
inline fapi2::ReturnCode set_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_COLUMN_BITS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of
/// DRAM columns is 2^N, where N is the number of column address bits
///
inline fapi2::ReturnCode set_dram_column_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_COLUMN_BITS, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_COLUMN_BITS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_COLUMN_BITS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of
/// DRAM columns is 2^N, where N is the number of column address bits
///
inline fapi2::ReturnCode set_dram_column_bits(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_COLUMN_BITS, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_COLUMN_BITS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_ROW_BITS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address
/// bits. Actual number of DRAM rows is 2^N, where N is the number of row address bits
///
inline fapi2::ReturnCode set_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_ROW_BITS, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_ROW_BITS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_ROW_BITS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address
/// bits. Actual number of DRAM rows is 2^N, where N is the number of row address bits
///
inline fapi2::ReturnCode set_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_ROW_BITS, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_ROW_BITS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PRIM_DIE_COUNT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Primary SDRAM Die Count. Decodes Byte 6 (bits 6~4).
///
inline fapi2::ReturnCode set_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PRIM_DIE_COUNT, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_PRIM_DIE_COUNT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PRIM_DIE_COUNT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Primary SDRAM Die Count. Decodes Byte 6 (bits 6~4).
///
inline fapi2::ReturnCode set_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PRIM_DIE_COUNT, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_PRIM_DIE_COUNT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PRIM_STACK_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Primary SDRAM Package Type (bits 1~0). Decodes Byte 6. This byte defines
/// the primary set of SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load
/// stack = 3DS
///
inline fapi2::ReturnCode set_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PRIM_STACK_TYPE, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_PRIM_STACK_TYPE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PRIM_STACK_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Primary SDRAM Package Type (bits 1~0). Decodes Byte 6. This byte defines
/// the primary set of SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load
/// stack = 3DS
///
inline fapi2::ReturnCode set_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PRIM_STACK_TYPE, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_PRIM_STACK_TYPE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PRIM_BUS_WIDTH setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Primary bus with (bits 1~0). Decodes Byte 13.
///
inline fapi2::ReturnCode set_prim_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PRIM_BUS_WIDTH, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_PRIM_BUS_WIDTH, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PRIM_BUS_WIDTH setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Primary bus with (bits 1~0). Decodes Byte 13.
///
inline fapi2::ReturnCode set_prim_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PRIM_BUS_WIDTH, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_PRIM_BUS_WIDTH, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_CHANNELS_PER_DIMM setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Number of channels per DIMM (bits 6~5). Decodes Byte 235.
///
inline fapi2::ReturnCode set_channels_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_CHANNELS_PER_DIMM, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_CHANNELS_PER_DIMM, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_CHANNELS_PER_DIMM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Number of channels per DIMM (bits 6~5). Decodes Byte 235.
///
inline fapi2::ReturnCode set_channels_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_CHANNELS_PER_DIMM, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_CHANNELS_PER_DIMM, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_PPR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
///
inline fapi2::ReturnCode set_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_PPR, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_PPR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_PPR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
///
inline fapi2::ReturnCode set_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_PPR, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_PPR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_SOFT_PPR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Soft Post Package Repair. Used in various locations and is evaluated
/// in mss_eff_cnfg.
///
inline fapi2::ReturnCode set_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_SOFT_PPR, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_SOFT_PPR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_SOFT_PPR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Soft Post Package Repair. Used in various locations and is evaluated
/// in mss_eff_cnfg.
///
inline fapi2::ReturnCode set_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_SOFT_PPR, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_SOFT_PPR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRCD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte 25
/// (7~0) and byte 112 (7~0). Each memory channel will have a value.
///
inline fapi2::ReturnCode set_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRCD, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRP setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
///
inline fapi2::ReturnCode set_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRP, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRAS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing
///
inline fapi2::ReturnCode set_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRAS, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes SPD
/// byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel will have
/// a value.
///
inline fapi2::ReturnCode set_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRC, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRFC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the Minimum
/// Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD byte 31
/// (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits 15~8) and
/// byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte 34 (bits
/// 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that selects refresh
/// mode. For 3DS, The tRFC time to the same logical rank is defined as tRFC_slr and
/// is specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
///
inline fapi2::ReturnCode set_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRFC, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TFAW setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same logical
/// rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices only) and specificed
/// as the value as for a monolithic DDR4 SDRAM equivalent density. Each memory channel
/// will have a value.
///
inline fapi2::ReturnCode set_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TFAW, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRRD_S setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a different
/// bank group in the same logical rank is defined as tRRD_slr and is specificed as
/// the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory channel
/// will have a value.
///
inline fapi2::ReturnCode set_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRRD_S, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRRD_L setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same bank
/// group in the same logical rank is defined as tRRD_L_slr and is specificed as the
/// value as for a monolithic DDR4 SDRAM of equivalent density. Each memory channel
/// will have a value.
///
inline fapi2::ReturnCode set_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRRD_L, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRRD_DLR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Activate to Activate Delay Time (different logical ranks) in nck (number
/// of clock cycles). For 3DS, The tRRD_S time to a different logical rank is defined
/// as tRRD_dlr. Each memory channel will have a value.
///
inline fapi2::ReturnCode set_dram_trrd_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRRD_DLR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TCCD_L setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR5 RDs. Each
/// memory channel will have a value.
///
inline fapi2::ReturnCode set_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TCCD_L, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TWR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits 7~0).
/// Each memory channel will have a value.
///
inline fapi2::ReturnCode set_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TWR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TWTR_S setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock cycles).
/// Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel will have
/// a value.
///
inline fapi2::ReturnCode set_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TWTR_S, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TWTR_L setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles). Decodes
/// byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a value.
///
inline fapi2::ReturnCode set_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TWTR_L, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TMAW setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Maximum Activate Window in nck (number of clock cycles). Decodes SPD byte 7 (bits
/// 5~4). Depends on tREFI multiplier. Each memory channel will have a value.
///
inline fapi2::ReturnCode set_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TMAW, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_WIDTH setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits),
/// X8 (8 bits), X16 (16 bits), X32 (32 bits).
///
inline fapi2::ReturnCode set_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_WIDTH, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_WIDTH, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_WIDTH setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits),
/// X8 (8 bits), X16 (16 bits), X32 (32 bits).
///
inline fapi2::ReturnCode set_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_WIDTH, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_WIDTH, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Total number of ranks in each DIMM. For monolithic and multi-load stack
/// modules (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD
/// Byte 12 bits 5~3). For single load stack (3DS) modules this value represents the
/// number of logical ranks per DIMM. Logical rank refers the individually addressable
/// die in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
///
inline fapi2::ReturnCode set_logical_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Total number of ranks in each DIMM. For monolithic and multi-load stack
/// modules (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD
/// Byte 12 bits 5~3). For single load stack (3DS) modules this value represents the
/// number of logical ranks per DIMM. Logical rank refers the individually addressable
/// die in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
///
inline fapi2::ReturnCode set_logical_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_3DS_HEIGHT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Setting for 3DS stack. Calculated from logical_ranks / master_ranks
///
inline fapi2::ReturnCode set_3ds_height(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t i_value)
{
    uint16_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_3DS_HEIGHT, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_3DS_HEIGHT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_3DS_HEIGHT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Setting for 3DS stack. Calculated from logical_ranks / master_ranks
///
inline fapi2::ReturnCode set_3ds_height(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                        uint16_t (&i_array)[2])
{
    uint16_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_3DS_HEIGHT, i_target, l_value) );
    memcpy(&l_value, i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_3DS_HEIGHT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REGISTER_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Register Type Decodes SPD Byte 131
///
inline fapi2::ReturnCode set_register_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REGISTER_TYPE, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_REGISTER_TYPE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REGISTER_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Register Type Decodes SPD Byte 131
///
inline fapi2::ReturnCode set_register_type(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REGISTER_TYPE, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_REGISTER_TYPE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_MODULE_MFG_ID setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Module MFG ID Decodes SPD Byte 320 and 321 for ISDIMMs (Fujitsu, US
/// Modular) Decodes SPD Byte 512 and 513 for DDIMMs (Micron, Samsung, Smart)
///
inline fapi2::ReturnCode set_module_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t i_value)
{
    uint16_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_MODULE_MFG_ID, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_MODULE_MFG_ID, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_MODULE_MFG_ID setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Module MFG ID Decodes SPD Byte 320 and 321 for ISDIMMs (Fujitsu, US
/// Modular) Decodes SPD Byte 512 and 513 for DDIMMs (Micron, Samsung, Smart)
///
inline fapi2::ReturnCode set_module_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2])
{
    uint16_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_MODULE_MFG_ID, i_target, l_value) );
    memcpy(&l_value, i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_MODULE_MFG_ID, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_MFG_ID setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 for ISDIMMs Decodes
/// SPD Byte 552 and 553 for DDIMMs
///
inline fapi2::ReturnCode set_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t i_value)
{
    uint16_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_MFG_ID, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_MFG_ID, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_MFG_ID setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 for ISDIMMs Decodes
/// SPD Byte 552 and 553 for DDIMMs
///
inline fapi2::ReturnCode set_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2])
{
    uint16_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_MFG_ID, i_target, l_value) );
    memcpy(&l_value, i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_MFG_ID, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_RCD_MFG_ID setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Register Manufacturer ID Code Decodes SPD Byte 133 and 134 DDIMM Module
/// Bytes 265 and 266
///
inline fapi2::ReturnCode set_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t i_value)
{
    uint16_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_RCD_MFG_ID, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_RCD_MFG_ID, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_RCD_MFG_ID setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Register Manufacturer ID Code Decodes SPD Byte 133 and 134 DDIMM Module
/// Bytes 265 and 266
///
inline fapi2::ReturnCode set_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                        uint16_t (&i_array)[2])
{
    uint16_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_RCD_MFG_ID, i_target, l_value) );
    memcpy(&l_value, i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_RCD_MFG_ID, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REGISTER_REV setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Register Revision Number Decodes SPD Byte 135
///
inline fapi2::ReturnCode set_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REGISTER_REV, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_REGISTER_REV, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REGISTER_REV setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Register Revision Number Decodes SPD Byte 135
///
inline fapi2::ReturnCode set_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REGISTER_REV, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_REGISTER_REV, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PACKAGE_RANK_MAP setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM][DQ_NIBBLES] Package Rank Map Decodes SPD Byte 60 - 77 (Bits 7~6)
///
inline fapi2::ReturnCode set_package_rank_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[20])
{
    uint8_t l_value[2][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PACKAGE_RANK_MAP, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 20);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_PACKAGE_RANK_MAP, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PACKAGE_RANK_MAP setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM][DQ_NIBBLES] Package Rank Map Decodes SPD Byte 60 - 77 (Bits 7~6)
///
inline fapi2::ReturnCode set_package_rank_map(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][20])
{
    uint8_t l_value[2][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PACKAGE_RANK_MAP, i_target, l_value) );
    memcpy(&l_value, i_array, 40);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_PACKAGE_RANK_MAP, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NIBBLE_MAP setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM][DQ_NIBBLES] Nibble Map Decodes SPD Byte 60 - 77 (Bits 5~0) for DDR4
///
inline fapi2::ReturnCode set_nibble_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t (&i_array)[20])
{
    uint8_t l_value[2][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NIBBLE_MAP, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 20);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_NIBBLE_MAP, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NIBBLE_MAP setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM][DQ_NIBBLES] Nibble Map Decodes SPD Byte 60 - 77 (Bits 5~0) for DDR4
///
inline fapi2::ReturnCode set_nibble_map(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                        uint8_t (&i_array)[2][20])
{
    uint8_t l_value[2][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NIBBLE_MAP, i_target, l_value) );
    memcpy(&l_value, i_array, 40);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_NIBBLE_MAP, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_SIZE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] DIMM Size, in GB Used in various locations
///
inline fapi2::ReturnCode set_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t i_value)
{
    uint32_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_SIZE, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_SIZE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_SIZE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint32_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] DIMM Size, in GB Used in various locations
///
inline fapi2::ReturnCode set_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                       uint32_t (&i_array)[2])
{
    uint32_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_SIZE, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_SIZE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_SPARE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg.
/// Array indexes are [DIMM][RANK]
///
inline fapi2::ReturnCode set_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_SPARE, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_SPARE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_SPARE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg.
/// Array indexes are [DIMM][RANK]
///
inline fapi2::ReturnCode set_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_SPARE, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_SPARE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_CL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  CAS Latency. Each memory channel will have a value.
///
inline fapi2::ReturnCode set_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_CL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_MDS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Controls if the given target has an MDS (managed DRAM solution)
///
inline fapi2::ReturnCode set_dram_mds(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_MDS, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Specifies the number of master ranks per DIMM. Represents the number
/// of physical ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4.
/// Byte 12 (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers
/// to the collections of devices on the module sharing common chip select signals.
///
inline fapi2::ReturnCode set_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Specifies the number of master ranks per DIMM. Represents the number
/// of physical ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4.
/// Byte 12 (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers
/// to the collections of devices on the module sharing common chip select signals.
///
inline fapi2::ReturnCode set_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_RANKS_CONFIGED setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used by PRD.
///
inline fapi2::ReturnCode set_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_RANKS_CONFIGED, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_RANKS_CONFIGED, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_RANKS_CONFIGED setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used by PRD.
///
inline fapi2::ReturnCode set_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_RANKS_CONFIGED, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_RANKS_CONFIGED, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TREFI setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). This depends on
/// MRW attribute that selects fine refresh mode (x1, x2, x4). From DDR4 spec (79-4A).
/// For 3DS, the tREFI time to the same logical rank is defined as tRFC_slr1, tRFC_slr2,
/// or tRFC_slr4.
///
inline fapi2::ReturnCode set_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TREFI, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRTP setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Internal Read to Precharge Delay. From the DDR4 spec (79-4A). Each memory channel
/// will have a value.
///
inline fapi2::ReturnCode set_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRTP, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRFC_DLR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Minimum Refresh Recovery Delay Time (different logical ranks) in nck (number of
/// clock cyles). Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4) depends on
/// MRW attribute that selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC time
/// to different logical ranks are defined as tRFC_dlr
///
inline fapi2::ReturnCode set_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_TRFC_DLR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_FREQ setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint64_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Frequency of this memory channel in MT/s (Mega Transfers per second)
///
inline fapi2::ReturnCode set_freq(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint64_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_FREQ, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_SPD_REVISION setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  SPD Revision (SPD Byte 1)
///
inline fapi2::ReturnCode set_spd_revision(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_SPD_REVISION, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_SPD_CONTENT_REVISION setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  SPD content revision (SPD Byte 221)
///
inline fapi2::ReturnCode set_spd_content_revision(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_SPD_CONTENT_REVISION, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_SUPPORTED_RCD setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Byte 264: Registered Clock Drivers (RCD). DDIMM SPD spec. Module's supported
/// RCD options
///
inline fapi2::ReturnCode set_supported_rcd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_SUPPORTED_RCD, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_SUPPORTED_RCD, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_SUPPORTED_RCD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] Byte 264: Registered Clock Drivers (RCD). DDIMM SPD spec. Module's supported
/// RCD options
///
inline fapi2::ReturnCode set_supported_rcd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_SUPPORTED_RCD, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_SUPPORTED_RCD, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_BYTE_ENABLES setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] These bits are used to activate or deactivate bytes in the DDR interface
/// of the differential memory buffer chip. Right aligned data.
///
inline fapi2::ReturnCode set_byte_enables(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t i_value)
{
    uint16_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_BYTE_ENABLES, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_BYTE_ENABLES, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_BYTE_ENABLES setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] These bits are used to activate or deactivate bytes in the DDR interface
/// of the differential memory buffer chip. Right aligned data.
///
inline fapi2::ReturnCode set_byte_enables(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2])
{
    uint16_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_BYTE_ENABLES, i_target, l_value) );
    memcpy(&l_value, i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_BYTE_ENABLES, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NIBBLE_ENABLES setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] These bits are used to select the active nibbles or DQS on the DDR interface.
/// Right aligned data.
///
inline fapi2::ReturnCode set_nibble_enables(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t i_value)
{
    uint32_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NIBBLE_ENABLES, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_NIBBLE_ENABLES, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NIBBLE_ENABLES setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint32_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] These bits are used to select the active nibbles or DQS on the DDR interface.
/// Right aligned data.
///
inline fapi2::ReturnCode set_nibble_enables(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint32_t (&i_array)[2])
{
    uint32_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NIBBLE_ENABLES, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_NIBBLE_ENABLES, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_EFF_DRAM_MODULE_HEIGHT setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM] DRAM Modlue Height Decodes SPD Byte 193
///
inline fapi2::ReturnCode set_dram_module_height(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DRAM_MODULE_HEIGHT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_VOLT_VDDR setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Voltage, each voltage rail would need to have a value.
///
inline fapi2::ReturnCode set_volt_vddr(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint32_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_VOLT_VDDR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_VOLT_VDDQ setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM Voltage, each voltage rail would need to have a value.
///
inline fapi2::ReturnCode set_volt_vddq(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint32_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_VOLT_VDDQ, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_VOLT_VPP setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM VPP Voltage, each voltage rail would need to have a value.
///
inline fapi2::ReturnCode set_volt_vpp(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint32_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_VOLT_VPP, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_Z_MODE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Determines DDIMM memory controller P series versus Z series specific settings.
///
inline fapi2::ReturnCode set_z_mode(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_Z_MODE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_SERIAL_NUMBER setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  IBM DDIMM Serial number and CCIN number Decodes SPD Byte 416 - 441 Currently only
/// DDR5 will be using this attribute
///
inline fapi2::ReturnCode set_eff_dimm_serial_number(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t (&i_array)[26])
{
    uint8_t l_value[26] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_SERIAL_NUMBER, i_target, l_value) );
    memcpy(&l_value, i_array, 26);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_SERIAL_NUMBER, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDIMM RAW card reference design SPD encoding Decodes SPD Byte 232 bits 0-4 Currently
/// only DDR5 will be using this attribute
///
inline fapi2::ReturnCode set_eff_dimm_raw_card_reference_design(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_RAW_CARD_REFERENCE_DESIGN, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DDIMM RAW card design revision number Decodes SPD Byte 232 bits 5-7 Currently only
/// DDR5 will be using this attribute
///
inline fapi2::ReturnCode set_eff_dimm_raw_card_design_revision(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_DIMM_RAW_CARD_DESIGN_REVISION, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_SI_SIGNATURE_HASH setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Hash Signature for SI settings from SPD. The hash signature is 32bits for 256 bytes
/// of data.
///
inline fapi2::ReturnCode set_si_signature_hash(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint32_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_SIGNATURE_HASH, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CA setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Command/Address in
/// tens of Ohms.
///
inline fapi2::ReturnCode set_si_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CA, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CA, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CA setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Command/Address in
/// tens of Ohms.
///
inline fapi2::ReturnCode set_si_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CA, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CA, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CKE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Clock Enable in tens
/// of Ohms.
///
inline fapi2::ReturnCode set_si_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CKE, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CKE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CKE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Clock Enable in tens
/// of Ohms.
///
inline fapi2::ReturnCode set_si_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CKE, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CKE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Chip Select in tens
/// of Ohms.
///
inline fapi2::ReturnCode set_si_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CS, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Chip Select in tens
/// of Ohms.
///
inline fapi2::ReturnCode set_si_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CS, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_ODT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for On Die Termination
/// in tens of Ohms.
///
inline fapi2::ReturnCode set_si_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_ODT, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_ODT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_ODT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for On Die Termination
/// in tens of Ohms.
///
inline fapi2::ReturnCode set_si_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_ODT, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_ODT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] DQ and DQS Drive Impedance.
///
inline fapi2::ReturnCode set_si_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] DQ and DQS Drive Impedance.
///
inline fapi2::ReturnCode set_si_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_PREAMBLE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Number of clocks used for read/write preamble. Calibration only
/// uses 1 nCK preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option.
/// The value of "0" means 1 nCK preamble, the value of "1" means 2 nCK preamble. Bit
/// 3 for READ preamble, and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK preamble
/// for both READ and WRITE
///
inline fapi2::ReturnCode set_si_dram_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_PREAMBLE, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_PREAMBLE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_PREAMBLE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Number of clocks used for read/write preamble. Calibration only
/// uses 1 nCK preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option.
/// The value of "0" means 1 nCK preamble, the value of "1" means 2 nCK preamble. Bit
/// 3 for READ preamble, and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK preamble
/// for both READ and WRITE
///
inline fapi2::ReturnCode set_si_dram_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_PREAMBLE, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_PREAMBLE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_NOM setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] DRAM side Nominal Termination Resistance in Ohms.
///
inline fapi2::ReturnCode set_si_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_NOM, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_RTT_NOM, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_NOM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] DRAM side Nominal Termination Resistance in Ohms.
///
inline fapi2::ReturnCode set_si_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_NOM, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_RTT_NOM, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_PARK setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] DRAM side Park Termination Resistance in Ohms.
///
inline fapi2::ReturnCode set_si_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_PARK, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_RTT_PARK, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_PARK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] DRAM side Park Termination Resistance in Ohms.
///
inline fapi2::ReturnCode set_si_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_PARK, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_RTT_PARK, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_WR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] DRAM side Write Termination Resistance in Ohms. Note: This attr
/// is for DDR4 ONLY
///
inline fapi2::ReturnCode set_si_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_WR, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_RTT_WR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_WR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] DRAM side Write Termination Resistance in Ohms. Note: This attr
/// is for DDR4 ONLY
///
inline fapi2::ReturnCode set_si_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_WR, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_DRAM_RTT_WR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_GEARDOWN_MODE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM][RANK] Gear Down Mode. This is for DDR4 MRS3. Each memory channel will
/// have a value.
///
inline fapi2::ReturnCode set_si_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_GEARDOWN_MODE, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_GEARDOWN_MODE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_GEARDOWN_MODE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  ARRAY[DIMM][RANK] Gear Down Mode. This is for DDR4 MRS3. Each memory channel will
/// have a value.
///
inline fapi2::ReturnCode set_si_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_GEARDOWN_MODE, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_GEARDOWN_MODE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Tx drive impedance for DQ/DQS of all ranks in ohms
///
inline fapi2::ReturnCode set_si_mc_drv_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_DQ_DQS, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_DQ_DQS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Tx drive impedance for DQ/DQS of all ranks in ohms
///
inline fapi2::ReturnCode set_si_mc_drv_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_DQ_DQS, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_DQ_DQS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  (DEPRECATED) Superceded by ATTR_MEM_SI_PHY_EQUALIZATION Left in as a workaround
/// to hostboot CI failing due to removal of attribute Array[DIMM][RANK] Memory Controller
/// side Receiver Equalization for Data and Data Strobe Lines.
///
inline fapi2::ReturnCode set_si_mc_rcv_eq_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  (DEPRECATED) Superceded by ATTR_MEM_SI_PHY_EQUALIZATION Left in as a workaround
/// to hostboot CI failing due to removal of attribute Array[DIMM][RANK] Memory Controller
/// side Receiver Equalization for Data and Data Strobe Lines.
///
inline fapi2::ReturnCode set_si_mc_rcv_eq_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  (DEPRECATED) Superceded by ATTR_MEM_SI_PHY_EQUALIZATION Left in as a workaround
/// to hostboot CI failing due to removal of attribute Array[DIMM][RANK] Memory Controller
/// side Drive Equalization for Data and Data Strobe Lines.
///
inline fapi2::ReturnCode set_si_mc_drv_eq_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  (DEPRECATED) Superceded by ATTR_MEM_SI_PHY_EQUALIZATION Left in as a workaround
/// to hostboot CI failing due to removal of attribute Array[DIMM][RANK] Memory Controller
/// side Drive Equalization for Data and Data Strobe Lines.
///
inline fapi2::ReturnCode set_si_mc_drv_eq_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_PHY_EQUALIZATION setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive and Receive Equalization for Data
/// and Data Strobe Lines. Bit 6 - Driver FFE Bit 7 - Receiver DFE 0 = disable, 1 =
/// enable
///
inline fapi2::ReturnCode set_si_phy_equalization(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_PHY_EQUALIZATION, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_PHY_EQUALIZATION, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_PHY_EQUALIZATION setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive and Receive Equalization for Data
/// and Data Strobe Lines. Bit 6 - Driver FFE Bit 7 - Receiver DFE 0 = disable, 1 =
/// enable
///
inline fapi2::ReturnCode set_si_phy_equalization(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_PHY_EQUALIZATION, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_PHY_EQUALIZATION, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CLK setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance for Clock in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CLK, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CLK, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CLK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance for Clock in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CLK, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CLK, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance for Address, Bank Address,
/// Bank Group and Activate Lines in Ohms. DDR4 configs values are in Ohms. DDR5 configs
/// (SDR_ and DDR_) values are the possible SPD encoding for ATx impedance. The CSR
/// value is derived from the lookup table of byte 32 in DDR5 SPD spec in ody_ddrphy_phyinit
///
inline fapi2::ReturnCode set_si_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance for Address, Bank Address,
/// Bank Group and Activate Lines in Ohms. DDR4 configs values are in Ohms. DDR5 configs
/// (SDR_ and DDR_) values are the possible SPD encoding for ATx impedance. The CSR
/// value is derived from the lookup table of byte 32 in DDR5 SPD spec in ody_ddrphy_phyinit
///
inline fapi2::ReturnCode set_si_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CNTL setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance for Clock Enable, ODT,
/// Parity, and Reset Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CNTL, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CNTL, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CNTL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance for Clock Enable, ODT,
/// Parity, and Reset Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CNTL, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CNTL, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CSCID setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance for Chip Select and Chip
/// ID Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CSCID, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CSCID, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CSCID setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance for Chip Select and Chip
/// ID Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CSCID, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CSCID, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance Pull Down for Data and
/// Data Strobe Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_dq_dqs_pull_down(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t (&i_array)[4])
{
    uint16_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance Pull Down for Data and
/// Data Strobe Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_dq_dqs_pull_down(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2][4])
{
    uint16_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN, i_target, l_value) );
    memcpy(&l_value, i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance Pull Up for Data and Data
/// Strobe Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_dq_dqs_pull_up(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t (&i_array)[4])
{
    uint16_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Impedance Pull Up for Data and Data
/// Strobe Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_imp_dq_dqs_pull_up(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2][4])
{
    uint16_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP, i_target, l_value) );
    memcpy(&l_value, i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Clock in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_clk(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Clock in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_clk(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Address, Bank Address,
/// Bank Group and Activate Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Address, Bank Address,
/// Bank Group and Activate Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Clock Enable, ODT,
/// Parity, and Reset Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_cntl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Clock Enable, ODT,
/// Parity, and Reset Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Chip Select and Chip
/// ID Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_cscid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Chip Select and Chip
/// ID Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Data and Data Strobe
/// Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Drive Slew Rate for Data and Data Strobe
/// Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_drv_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_IMP_ALERT_N setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Memory Controller side Receiver Impedance. Alert_N line in Ohms.
///
inline fapi2::ReturnCode set_si_mc_rcv_imp_alert_n(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_ALERT_N, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_ALERT_N, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_IMP_ALERT_N setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Memory Controller side Receiver Impedance. Alert_N line in Ohms.
///
inline fapi2::ReturnCode set_si_mc_rcv_imp_alert_n(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_ALERT_N, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_ALERT_N, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Receiver Impedance. Data and Data Strobe
/// Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t (&i_array)[4])
{
    uint16_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] Memory Controller side Receiver Impedance. Data and Data Strobe
/// Lines in Ohms.
///
inline fapi2::ReturnCode set_si_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2][4])
{
    uint16_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(&l_value, i_array, 16);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_ODT_RD setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] READ, On Die Termination triggering bitmap. Use bitmap to determine
/// which ODT to fire for the designated rank. The bits in 8 bit field are [DIMM0 ODT0][DIMM0
/// ODT1][DIMM0 ODT2][DIMM0 ODT3][DIMM1 ODT0][DIMM1 ODT1][DIMM1 ODT2][DIMM1 ODT3] For
/// Explorer: Only bits 0,1,4,5 are used. They correspond to A0 A1 -- -- B0 B1 -- --
///
inline fapi2::ReturnCode set_si_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_ODT_RD, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_ODT_RD, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_ODT_RD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] READ, On Die Termination triggering bitmap. Use bitmap to determine
/// which ODT to fire for the designated rank. The bits in 8 bit field are [DIMM0 ODT0][DIMM0
/// ODT1][DIMM0 ODT2][DIMM0 ODT3][DIMM1 ODT0][DIMM1 ODT1][DIMM1 ODT2][DIMM1 ODT3] For
/// Explorer: Only bits 0,1,4,5 are used. They correspond to A0 A1 -- -- B0 B1 -- --
///
inline fapi2::ReturnCode set_si_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                       uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_ODT_RD, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_ODT_RD, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_ODT_WR setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] WRITE, On Die Termination triggering bitmap. Use bitmap to determine
/// which ODT to fire for the designated rank. The bits in 8 bit field are [DIMM0 ODT0][DIMM0
/// ODT1][DIMM0 ODT2][DIMM0 ODT3][DIMM1 ODT0][DIMM1 ODT1][DIMM1 ODT2][DIMM1 ODT3] For
/// Explorer: Only bits 0,1,4,5 are used. They correspond to A0 A1 -- -- B0 B1 -- --
///
inline fapi2::ReturnCode set_si_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t (&i_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_ODT_WR, l_port, l_value) );
    memcpy(&(l_value[mss::index(i_target)][0]), i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_ODT_WR, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_ODT_WR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM][RANK] WRITE, On Die Termination triggering bitmap. Use bitmap to determine
/// which ODT to fire for the designated rank. The bits in 8 bit field are [DIMM0 ODT0][DIMM0
/// ODT1][DIMM0 ODT2][DIMM0 ODT3][DIMM1 ODT0][DIMM1 ODT1][DIMM1 ODT2][DIMM1 ODT3] For
/// Explorer: Only bits 0,1,4,5 are used. They correspond to A0 A1 -- -- B0 B1 -- --
///
inline fapi2::ReturnCode set_si_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                       uint8_t (&i_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_ODT_WR, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_ODT_WR, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_VREF_DRAM_WR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode set_si_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_VREF_DRAM_WR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_VREF_MC_RD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of Vdd. Disable = 0, defined as no HW adjustment or Vdd/2 if possible.
///
inline fapi2::ReturnCode set_si_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint32_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_VREF_MC_RD, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_WINDAGE_RD_CTR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] int16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage offset
/// in units of pico-seconds[ps]. Default is 0 for no windage adjustment. Specification
/// of the value in this file is 2's compliment hex
///
inline fapi2::ReturnCode set_si_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        int16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_WINDAGE_RD_CTR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC1X setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC1X - QxCSn_n Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC1X, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC1X, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC1X setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC1X - QxCSn_n Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc1x(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC1X, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC1X, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC2X setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC2X - QxCn Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC2X, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC2X, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC2X setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC2X - QxCn Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc2x(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC2X, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC2X, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC3X setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC3X - QxCKEn Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC3X, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC3X, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC3X setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC3X - QxCKEn Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc3x(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC3X, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC3X, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC4X setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC4X - QxODTn Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC4X, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC4X, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC4X setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC4X - QxODTn Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc4x(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC4X, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC4X, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC5X setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC5X - QxCA Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC5X, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC5X, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC5X setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC5X - QxCA Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc5x(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC5X, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC5X, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC6X setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC6X - Y1/Y3 Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC6X, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC6X, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC6X setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC6X - Y1/Y3 Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc6x(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC6X, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC6X, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC7X setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC7X - Y0/Y2 Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc7x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t i_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC7X, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC7X, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_DIMM_DDR4_F1RC7X setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Array[DIMM]. F1RC7X - Y0/Y2 Output Delay Control Word from the DDR4 RCD Spec.
///
inline fapi2::ReturnCode set_ddr4_f1rc7x(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC7X, i_target, l_value) );
    memcpy(&l_value, i_array, 2);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_DIMM_DDR4_F1RC7X, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  PHY Drive Impedance Pull Up for Data and Data Strobe Lines when equalization is
/// enabled (in Ohms). Used only for DDR5.
///
inline fapi2::ReturnCode set_si_phy_drv_imp_dq_dqs_pull_up(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_SI_PHY_DRV_IMP_DQ_DQS_PULL_UP, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_EFF_MODULE_THERMAL_SENSORS setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Number of module thermal sensors
///
inline fapi2::ReturnCode set_module_thermal_sensors(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_MODULE_THERMAL_SENSORS, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_0_AVAIL setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The availability of thermal sensor 0
///
inline fapi2::ReturnCode set_therm_sensor_0_availability(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_0_AVAIL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The availability of thermal sensor 0's secondary sensor
///
inline fapi2::ReturnCode set_therm_sensor_0_secondary_availability(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_AVAIL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_0_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The sensor type of thermal sensor 0 JC42 = JEDEC_DDR4_JC42_4_COMPLIANT EMC1412 =
/// MCHP_EMC1412_OR_COMPATIBLE
///
inline fapi2::ReturnCode set_therm_sensor_0_type(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_0_TYPE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_0_USAGE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The chosen usage monitor of thermal sensor 0. Note that the SPD encoding of DRAM_AND_PMIC
/// usage (0x03) is not supported and will be changed to PMIC in this attribute.
///
inline fapi2::ReturnCode set_therm_sensor_0_usage(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_0_USAGE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_0_I2C_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Thermal Sensor 0 I2C Address
///
inline fapi2::ReturnCode set_therm_sensor_0_i2c_addr(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_0_I2C_ADDR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_1_AVAIL setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The availability of thermal sensor 1
///
inline fapi2::ReturnCode set_therm_sensor_1_availability(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_1_AVAIL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The availability of thermal sensor 1's secondary sensor
///
inline fapi2::ReturnCode set_therm_sensor_1_secondary_availability(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_AVAIL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_1_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The sensor type of thermal sensor 1 JC42 = JEDEC_DDR4_JC42_4_COMPLIANT EMC1412 =
/// MCHP_EMC1412_OR_COMPATIBLE
///
inline fapi2::ReturnCode set_therm_sensor_1_type(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_1_TYPE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_1_USAGE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The chosen usage monitor of thermal sensor 1. Note that the SPD encoding of DRAM_AND_PMIC
/// usage (0x03) is not supported and will be changed to PMIC in this attribute.
///
inline fapi2::ReturnCode set_therm_sensor_1_usage(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_1_USAGE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_1_I2C_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Thermal Sensor 1 I2C Address
///
inline fapi2::ReturnCode set_therm_sensor_1_i2c_addr(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_1_I2C_ADDR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_2_AVAIL setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The availability of thermal sensor 2
///
inline fapi2::ReturnCode set_therm_sensor_2_availability(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_2_AVAIL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_2_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The sensor type of thermal sensor 2 JC42 = JEDEC_DDR4_JC42_4_COMPLIANT EMC1412 =
/// MCHP_EMC1412_OR_COMPATIBLE
///
inline fapi2::ReturnCode set_therm_sensor_2_type(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_2_TYPE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_2_USAGE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The chosen usage monitor of thermal sensor 2. Note that the SPD encoding of DRAM_AND_PMIC
/// usage (0x03) is not supported and will be changed to PMIC in this attribute.
///
inline fapi2::ReturnCode set_therm_sensor_2_usage(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_2_USAGE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_2_I2C_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Thermal sensor 2 I2C Address
///
inline fapi2::ReturnCode set_therm_sensor_2_i2c_addr(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_2_I2C_ADDR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_3_AVAIL setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The availability of thermal sensor 3
///
inline fapi2::ReturnCode set_therm_sensor_3_availability(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_3_AVAIL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_3_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The sensor type of thermal sensor 3 JC42 = JEDEC_DDR4_JC42_4_COMPLIANT EMC1412 =
/// MCHP_EMC1412_OR_COMPATIBLE
///
inline fapi2::ReturnCode set_therm_sensor_3_type(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_3_TYPE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_3_USAGE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The chosen usage monitor of thermal sensor 3. Note that the SPD encoding of DRAM_AND_PMIC
/// usage (0x03) is not supported and will be changed to PMIC in this attribute.
///
inline fapi2::ReturnCode set_therm_sensor_3_usage(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_3_USAGE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_3_I2C_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Thermal sensor 3 I2C Address
///
inline fapi2::ReturnCode set_therm_sensor_3_i2c_addr(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_3_I2C_ADDR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_DIFF_AVAIL setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The availability of the differential onchip thermal sensor
///
inline fapi2::ReturnCode set_therm_sensor_differential_availability(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_DIFF_AVAIL, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_DIFF_TYPE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The sensor type of the differential onchip thermal sensor JC42 = JEDEC_DDR4_JC42_4_COMPLIANT
/// EMC1412 = MCHP_EMC1412_OR_COMPATIBLE
///
inline fapi2::ReturnCode set_therm_sensor_differential_type(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_DIFF_TYPE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The chosen usage monitor of the differential onchip thermal sensor MB_INT_DTM =
/// MEMORY_BUFFER_INTERNAL_DTM MB_INT_DTM_REM = MEMORY_BUFFER_INTERNAL_DTM_REMOTE_SENSE
///
inline fapi2::ReturnCode set_therm_sensor_differential_usage(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Differential onchip thermal sensor I2C address
///
inline fapi2::ReturnCode set_therm_sensor_differential_i2c_addr(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_DIFF_I2C_ADDR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Secondary Thermal Sensor 0 I2C Address
///
inline fapi2::ReturnCode set_therm_sensor_0_secondary_i2c_addr(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_I2C_ADDR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Secondary Thermal Sensor 1 I2C Address
///
inline fapi2::ReturnCode set_therm_sensor_1_secondary_i2c_addr(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_I2C_ADDR, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Secondary Thermal Sensor 1 Location
///
inline fapi2::ReturnCode set_therm_sensor_1_secondary_location(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_1_SECOND_LOCATION, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Secondary Thermal Sensor 0 Location
///
inline fapi2::ReturnCode set_therm_sensor_0_secondary_location(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_0_SECOND_LOCATION, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_3_LOCATION setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Thermal Sensor 3 Location
///
inline fapi2::ReturnCode set_therm_sensor_3_location(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_3_LOCATION, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_2_LOCATION setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Thermal Sensor 2 Location
///
inline fapi2::ReturnCode set_therm_sensor_2_location(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_2_LOCATION, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_1_LOCATION setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Thermal Sensor 1 Location
///
inline fapi2::ReturnCode set_therm_sensor_1_location(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_1_LOCATION, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_0_LOCATION setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Thermal Sensor 0 Location
///
inline fapi2::ReturnCode set_therm_sensor_0_location(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_0_LOCATION, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_THERM_SENSOR_READ_OVERRIDE setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Thermal Sensor Init read override, by default thermal init should only read DRAM
/// sensor downstream of airflow direction. This override should only be used to force
/// all on-board temperature sensors to be configured for reading for DIMM testers and
/// Memory Qual.
///
inline fapi2::ReturnCode set_therm_sensor_read_override(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_THERM_SENSOR_READ_OVERRIDE, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for cfg_nm_n_per_port.
/// Note: For DDR5 this represents one side of the OCMB
///
inline fapi2::ReturnCode set_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  This is the throttle numerator setting for cfg_nm_n_per_slot. Note: For DDR5 this
/// represents one side of the OCMB
///
inline fapi2::ReturnCode set_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for cfg_nm_n_per_port. Note:
/// For DDR5 this represents one side of the OCMB
///
inline fapi2::ReturnCode set_runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Runtime throttle numerator setting for cfg_nm_n_per_slot. Note: For DDR5 this represents
/// one side of the OCMB
///
inline fapi2::ReturnCode set_runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_MEM_WATT_TARGET setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Total memory power used to throttle for each dimm Used to compute the throttles
/// on the channel and/or dimms for OCC OCC sets after IPL
///
inline fapi2::ReturnCode set_mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t i_value)
{
    uint32_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EXP_MEM_WATT_TARGET, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_MEM_WATT_TARGET, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_MEM_WATT_TARGET setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint32_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Total memory power used to throttle for each dimm Used to compute the throttles
/// on the channel and/or dimms for OCC OCC sets after IPL
///
inline fapi2::ReturnCode set_mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint32_t (&i_array)[2])
{
    uint32_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EXP_MEM_WATT_TARGET, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_MEM_WATT_TARGET, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_TOTAL_PWR_SLOPE setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  VDDR+VPP Power slope value for dimm creator: mss_eff_config consumer: mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode set_total_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t i_value)
{
    uint16_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EXP_TOTAL_PWR_SLOPE, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_TOTAL_PWR_SLOPE, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_TOTAL_PWR_SLOPE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  VDDR+VPP Power slope value for dimm creator: mss_eff_config consumer: mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode set_total_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2])
{
    uint16_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EXP_TOTAL_PWR_SLOPE, i_target, l_value) );
    memcpy(&l_value, i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_TOTAL_PWR_SLOPE, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_TOTAL_PWR_INTERCEPT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  VDDR+VPP Power intercept value for dimm
///
inline fapi2::ReturnCode set_total_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t i_value)
{
    uint16_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EXP_TOTAL_PWR_INTERCEPT, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_TOTAL_PWR_INTERCEPT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_TOTAL_PWR_INTERCEPT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  VDDR+VPP Power intercept value for dimm
///
inline fapi2::ReturnCode set_total_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[2])
{
    uint16_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EXP_TOTAL_PWR_INTERCEPT, i_target, l_value) );
    memcpy(&l_value, i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_TOTAL_PWR_INTERCEPT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_PORT_MAXPOWER setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Channel Pair Max Power output from thermal procedures
///
inline fapi2::ReturnCode set_port_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint32_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_PORT_MAXPOWER, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_DIMM_THERMAL_LIMIT setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint32_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DIMM Max Power based on a thermal limit Decoded from ATTR_MSS_MRW_THERMAL_POWER_LIMIT
///
inline fapi2::ReturnCode set_dimm_thermal_limit(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t i_value)
{
    uint32_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EXP_DIMM_THERMAL_LIMIT, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_DIMM_THERMAL_LIMIT, l_port, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_EXP_DIMM_THERMAL_LIMIT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint32_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DIMM Max Power based on a thermal limit Decoded from ATTR_MSS_MRW_THERMAL_POWER_LIMIT
///
inline fapi2::ReturnCode set_dimm_thermal_limit(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint32_t (&i_array)[2])
{
    uint32_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EXP_DIMM_THERMAL_LIMIT, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_EXP_DIMM_THERMAL_LIMIT, i_target, l_value) );

fapi_try_exit:
    return fapi2::current_err;
}


///
/// @brief ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for cfg_nm_n_per_port.
/// Note: This represents the combination of both sides of the OCMB for DDR5 config.
///
inline fapi2::ReturnCode set_ody_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  This is the throttle numerator setting for cfg_nm_n_per_slot Note: This represents
/// the combination of both sides of the OCMB for DDR5 config.
///
inline fapi2::ReturnCode set_ody_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>&
        i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for cfg_nm_n_per_port. Note:
/// This represents the combination of both sides of the OCMB for DDR5 config.
///
inline fapi2::ReturnCode set_ody_runtime_mem_throttled_n_commands_per_port(const
        fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Runtime throttle numerator setting for cfg_nm_n_per_slot Note: This represents the
/// combination of both sides of the OCMB for DDR5 config.
///
inline fapi2::ReturnCode set_ody_runtime_mem_throttled_n_commands_per_slot(const
        fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, i_value) );

fapi_try_exit:
    return fapi2::current_err;
}


} // attr
} // mss

#endif
