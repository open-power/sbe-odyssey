/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: public/src/import/public/common/libs/spi/spi_memory.H $       */
/*                                                                        */
/* OpenPOWER sbe Project                                                  */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2023,2024                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

/// @brief Drivers for SPI attached memory devices (SEEPROM / NOR Flash)
/// @author Joachim Fenkes <fenkes@de.ibm.com>

#pragma once

#include <fapi2.H>
#include <spi_base.H>

namespace spi
{

/**
 * @brief Abstract base class for a memory device
 *
 * Specific drivers are supposed to derive from this base class and override its virtual methods.
 * This way, calling code has a consistent API that is agnostic of the type of memory device.
 */
class AbstractMemoryDevice
{
    public:
        /**
         * @brief Read data from the device
         *
         * @param[in]  i_start   Start address of the read operation.
         *                       In ECC mode (ECC_ENABLED, ECC_DISCARD) this is a logical address
         *                       and must be a multiple of 8. In ECC_DISABLED mode this is a raw
         *                       address and can be any value.
         * @param[in]  i_length  Length of the read operation in bytes.
         *                       Same comments re ECC as i_start.
         * @param[out] o_buffer  Buffer to receive the read data; must be 8 byte aligned
         */
        virtual fapi2::ReturnCode read(uint32_t i_start, uint32_t i_length, void* o_buffer) const = 0;

        /**
         * @brief Begin a write operation to the device
         *
         * Large write operations may be broken up into smaller chunks of data, but to allow
         * for optimizations such as choosing the optimal erase block size on Flash devices
         * the intended total write length must be known ahead of time.
         *
         * Thus, each write operation must be initiated by a call to this method, followed by
         * arbitrarily many calls to write_data() (whose length must sum up to the total length
         * in the i_length parameter). At the end of the write, write_end() must be called to
         * allow for flushing of any unwritten data and clean-up.
         *
         * @param[in] i_start    Start address of the write operation.
         *                       In ECC mode (ECC_ENABLED, ECC_DISCARD) this is a logical address
         *                       and must be a multiple of 8. In ECC_DISABLED mode this is a raw
         *                       address and can be any value.
         * @param[in] i_length   Total length of the intended write operation in bytes.
         *                       Same comments re ECC as i_start.
         */
        virtual fapi2::ReturnCode write_begin(uint32_t i_start, uint32_t i_length) = 0;

        /**
         * @brief Submit data for an ongoing write operation
         *
         * If multiple calls to write_data() are being made, each call's data will be appended
         * where the previous call's data ended. In ECC mode (ECC_ENABLED, ECC_DISCARD) the ECC
         * bytes for this data will be generated by the driver.
         *
         * @param[in] i_buffer  Buffer containing the data to be written; must be 8 byte aligned
         * @param[in] i_length  Length of data in bytes; must be a multiple of 8 if ECC is enabled
         */
        virtual fapi2::ReturnCode write_data(const void* i_buffer, uint32_t i_length) = 0;

        /**
         * @brief Finish a write operation
         *
         * Flushes all unwritten data to the device and cleans up internal state.
         *
         * This will also check whether the sum of all write_data() calls match the total length
         * announced in the write_begin() call and raise an error if they don't match.
         */
        virtual fapi2::ReturnCode write_end() = 0;
};

/**
 * @brief Driver for a SEEPROM device following the 25 series industry standard
 */
class SEEPROMDevice : public AbstractMemoryDevice
{
    public:
        /**
         * @brief Construct a SEEPROM driver object
         *
         * @param[in] i_port     Communication port to which the device is attached
         * @param[in] i_raw_size Size of the device's memory array in bytes.
         *                       Will be used for range checking on reads and writes.
         * @param[in] i_verify   Read back and compare write data immediately after writing
         */
        SEEPROMDevice(const AbstractPort& i_port, uint32_t i_raw_size, bool i_verify) :
            iv_port(i_port), iv_raw_size(i_raw_size), iv_verify(i_verify),
            iv_ecc_mode(i_port.get_ecc_mode()), iv_write_active(false)
        {}

        /// @brief Implementation of read - see AbstractMemoryDevice::read() for details
        fapi2::ReturnCode read(uint32_t i_start, uint32_t i_length, void* o_buffer) const override;

        /// @brief Implementation of write_begin - see AbstractMemoryDevice::write_begin() for details
        fapi2::ReturnCode write_begin(uint32_t i_start, uint32_t i_length) override;

        /// @brief Implementation of write_data - see AbstractMemoryDevice::write_data() for details
        fapi2::ReturnCode write_data(const void* i_buffer, uint32_t i_length) override;

        /// @brief Implementation of write_end - see AbstractMemoryDevice::write_end() for details
        fapi2::ReturnCode write_end() override;

        /**
         * @brief Correct an address or length for ECC according to the input ECC mode
         * @param[in] i_ecc_mode ECC mode to consider
         * @param[in] i_value    Value to convert
         * @return ECC converted value unless the ECC mode is ECC_DISABLED
         */
        static inline uint32_t ecc_correct(ecc_mode i_ecc_mode, uint32_t i_value)
        {
            return (i_ecc_mode != ECC_DISABLED) ? (i_value / 8 * 9) : i_value;
        }

    protected:
        static const uint16_t WRITE_PAGE_SIZE = 256;
        static const uint16_t WRITE_PAGE_MASK = WRITE_PAGE_SIZE - 1;

        const AbstractPort& iv_port;
        const uint32_t iv_raw_size;
        const bool iv_verify;
        ecc_mode iv_ecc_mode;
        bool iv_write_active;

        enum seeprom_device_commands
        {
            X25_CMD_READ_STATUS = 0x05,
            X25_CMD_WRITE_ENABLE = 0x06,
            X25_CMD_WRITE_DISABLE = 0x04,

            // Commands with 24-bit address
            X25_ADDR_MASK = 0x00FFFFFF,
            X25_CMD_READ = 0x03000000,
            X25_CMD_PAGE_PROGRAM = 0x02000000,
        };

        enum status_reg
        {
            SR_WIP = 0x01,
            SR_WEL = 0x02,
        };

        enum operation_t
        {
            WRITE_BEGIN = 1,
            WRITE_DATA  = 2,
            WRITE_END   = 3,
        };

        enum write_operation_ffdc
        {
            OP_PAGE_WRITE,
            OP_BLOCK_ERASE,
        };

        uint8_t iv_page_buffer[WRITE_PAGE_SIZE] __attribute__((aligned(8)));
        uint32_t iv_write_start, iv_write_pos, iv_write_end, iv_buf_pos;

        bool iv_verify_fail;
        uint32_t iv_verify_fail_address, iv_verify_fail_length;

        /**
         * @brief Translate an address from logical to raw in ECC mode, otherwise don't
         */
        inline uint32_t ecc_correct(uint32_t i_value) const
        {
            return ecc_correct(iv_ecc_mode, i_value);
        }

        /**
         * @brief Read the device status register
         */
        inline fapi2::ReturnCode read_status(uint8_t& o_status) const
        {
            return iv_port.transaction(X25_CMD_READ_STATUS, 1, NULL, 0, &o_status, 1);
        }

        /**
         * @brief Set the write enable latch
         */
        inline fapi2::ReturnCode write_enable() const
        {
            return iv_port.transaction(X25_CMD_WRITE_ENABLE, 1, NULL, 0, NULL, 0);
        }

        /**
         * @brief Clear the write enable latch
         */
        inline fapi2::ReturnCode write_disable() const
        {
            return iv_port.transaction(X25_CMD_WRITE_DISABLE, 1, NULL, 0, NULL, 0);
        }

        /**
         * @brief Perform a read with a choice of ECC enabled or disabled
         *
         * @param[in]  i_start    Raw start address; no ECC correction will be applied
         * @param[in]  i_length   Raw read length; no ECC correction will be applied
         * @param[in]  i_use_ecc  Enable the communication port's ECC feature
         * @param[out] o_buffer   Output data buffer
         */
        fapi2::ReturnCode read_internal(
            uint32_t i_start, uint32_t i_length, bool i_use_ecc, void* o_buffer) const;

        /**
         * @brief Wait for a write/erase operation to complete
         *
         * This will also make sure that the write enable latch is cleared even in
         * case of an error.
         *
         * @param[in] i_timeout_ms  Maximum time the operation should take, in ms
         * @param[in] i_operation   Operation encoding for FFDC
         * @param[in] i_address     Operation address for FFDC
         * @param[in] i_length      Operation length for FFDC
         */
        fapi2::ReturnCode wait_for_write_complete(
            int i_timeout_ms, int i_operation, int i_address, int i_length) const;

        /**
         * @brief Check that the write call sequence is followed
         * @param[in] i_operation  Operation that was called
         * @param[in] i_expect     Expected state of iv_write_active
         */
        fapi2::ReturnCode check_write_active(operation_t i_operation, bool i_expect);

        /**
         * @brief Check a start address and length for ECC mode specific constraints
         */
        fapi2::ReturnCode check_start_and_length(uint32_t i_start, uint32_t i_length) const;

        /**
         * @brief Write a single page of data to the device
         *
         * @param[in] i_start   The raw device address at which to start writing
         * @param[in] i_length  Amount of bytes to write; must not cross a page boundary
         * @param[in] i_buffer  Buffer containing write data
         */
        fapi2::ReturnCode write_page(uint32_t i_start, uint32_t i_length, const uint8_t* i_buffer);

        /**
         * @brief Read back data from the device and compare to the expected data
         *
         * This does not immediately raise an error but store the fact that verify failed.
         * To turn this into an error code must call verify_check(); this is to allow drivers
         * to continue writing up to a point where aborting would cause less damage.
         *
         * @param[in] i_start   The raw device address at which to start reading
         * @param[in] i_length  Amount of bytes to read
         * @param[in] i_buffer  Buffer to compare to
         */
        fapi2::ReturnCode verify_write(uint32_t i_start, uint32_t i_length, const uint8_t* i_buffer);

        /**
         * @brief Assert if a previous verify failed
         */
        fapi2::ReturnCode verify_check() const;

        /**
         * @brief Commit the current page buffer content to the device
         * @param[in] i_final_write indicates that the call came from write_end() trying to tie up loose ends
         */
        virtual fapi2::ReturnCode flush_page_buf(bool i_final_write);

        /**
         * @brief Helper to write a single byte to the page buffer
         *
         * This flushes data out to the device whenever we cross a page boundary
         */
        fapi2::ReturnCode write_byte(uint8_t i_byte);
};

/**
 * @brief Driver for a NOR Flash device following the 25 series industry standard
 */
class FlashDevice : public SEEPROMDevice
{
    protected:
        static const uint32_t SMALLEST_ERASE_BLOCK_SIZE = 4096;
        static const uint32_t SMALLEST_ERASE_BLOCK_MASK = SMALLEST_ERASE_BLOCK_SIZE - 1;

    public:
        /**
         * @brief Device types supported by the driver
         */
        enum device_type
        {
            DEV_MICRON_MT25Q = 1,
            DEV_MACRONIX_MX66,
        };

        static const uint32_t ERASE_BUFFER_SIZE = SMALLEST_ERASE_BLOCK_SIZE;

        /**
         * @brief Construct a Flash driver object
         *
         * Write operations may require a temporary buffer for preserving erase block data
         * before it is erased. To facilitate use on embedded platforms that buffer is optional
         * and must be provided by the caller. If the buffer is not provided write operations
         * which are not strictly aligned to erase block boundaries will fail.
         *
         * @param[in] i_port          Communication port to which the device is attached
         * @param[in] i_devtype       Flash device type - if unclear you can use detect_device()
         * @param[in] i_raw_size      Size of the device's memory array in bytes.
         *                            Will be used for range checking on reads and writes.
         * @param[in] i_erase_buffer  Buffer for preserving partial erase block data.
         *                            Must be able to hold ERASE_BUFFER_SIZE bytes.
         *                            Can be omitted (i.e. a null pointer) if only reads or
         *                            erase block aligned writes are performed.
         * @param[in] i_verify        Read back and compare write data immediately after writing
         */
        FlashDevice(const AbstractPort& i_port,
                    device_type i_devtype,
                    uint32_t i_raw_size,
                    uint8_t* i_erase_buffer,
                    bool i_verify = true) :
            SEEPROMDevice(i_port, i_raw_size, i_verify), iv_devtype(i_devtype),
            iv_erase_buffer(i_erase_buffer), iv_recovered_from_error(false)
        {}

        /// @brief Implementation of write_begin - see AbstractMemoryDevice::write_begin() for details
        fapi2::ReturnCode write_begin(uint32_t i_start, uint32_t i_length) override;

        /// @brief Implementation of write_end - see AbstractMemoryDevice::write_end() for details
        fapi2::ReturnCode write_end() override;

        /**
         * @brief Detect the type of an attached device based on its device ID
         *
         * This sends a "get device ID" command to the specified port and attempts to match the
         * returned ID to a known device type.
         *
         * @param[in]  i_port     Communications port to query
         * @param[out] o_devtype  Detected device type
         */
        static fapi2::ReturnCode detect_device(const AbstractPort& i_port, device_type& o_devtype);

        /**
         * @brief Perform a soft reset of the Flash device
         *
         * This sends the soft reset sequence to the device which will cause the device status to be cleared.
         */
        fapi2::ReturnCode soft_reset();

    protected:
        enum extended_status
        {
            ES_NONE       = 0,
            ES_ERASE_FAIL = 0x01,
            ES_PROG_FAIL  = 0x02,
            ES_ERASE_SUSP = 0x04,
            ES_PROG_SUSP  = 0x08,
            ES_WRITE_PROT = 0x10,
        };

        const device_type iv_devtype;
        uint8_t* const iv_erase_buffer;

        uint32_t iv_erase_start, iv_erase_pos, iv_erase_end;
        uint8_t* iv_partial_end_restore_buffer;

        bool iv_recovered_from_error;

        /**
         * @brief New implementation of flush_page_buf() which incorporates erase support
         */
        fapi2::ReturnCode flush_page_buf(bool i_final_write) override;

        /**
         * @brief Attempt to write back the saved tail end of the last erase block, and terminate write state
         *
         * @param[in]  i_write_end  true if called from write_end(), false if called from an error path
         */
        fapi2::ReturnCode finalize_write(const bool i_write_end);

        /**
         * @brief Read the extended status of the device
         */
        virtual fapi2::ReturnCode read_extended_status(uint32_t i_address, extended_status& o_status) const;

        /**
         * @brief Read the extended status of the device and raise an error if the device reports a problem
         */
        fapi2::ReturnCode check_extended_status(uint32_t i_address, uint32_t i_length) const;

}; //class FlashDevice

}; //namespace spi
