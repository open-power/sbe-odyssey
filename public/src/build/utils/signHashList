#!/bin/sh
# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: public/src/build/utils/signHashList $
#
# OpenPOWER sbe Project
#
# Contributors Listed Below - COPYRIGHT 2016,2023
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG

# Exit if any command fails
set -e

# @brief Checks whether the file that is the input argument exists on the file
# system. The function
#        exits with an error status if the file DNE.
#
# @param[in] Full path to the file to check
check_path()
{
    if [ ! -f $1 ]; then
        echo "***ERROR | SBE | signHashList : $1 DNE!"
        exit 1
    fi
}

# @brief Print the help/usage info to the console
usage()
{
    echo "Usage"
    echo "!!!RUN ON A RHEL7 & RHEL8 MACHINE!!!"
    echo "Sign Hash List"
    echo "signHashList -i <Hash List to sign> -s <scratch dir path> -o <secure header output path>[-h ]"
    echo ""
    echo "Options:"
    echo "  -h: print this message."
    echo "  -s: scratch dir path."
    echo "  -i: Hash List to sign. "
    echo "  -o: Secure Header path"
    echo "  -S: Secure Version."
    echo "  -c: Component ID"
    echo "  -d: SBE Image Dir path in op-build"
    echo "  -f: signing Mode. Production/Development(Default)"
}

while getopts "h?s:i:o:d:S:f:c:" opt;
do
    case $opt in

        h)
            usage
            exit 0
        ;;

        s)
            SCRATCH_DIR=$OPTARG
        ;;

        i)
            HASH_LIST=$OPTARG
        ;;

        o)
            SECURE_HDR_PATH=$OPTARG
        ;;

	    d)
            SBE_IMG_DIR_OP=$OPTARG
        ;;

        c)
            COMPONENT_ID=$OPTARG
        ;;

        S)
            SV=$OPTARG
        ;;

        f)
            SIGNING_MODE=$OPTARG
        ;;

        *)
            echo "Bad option: $OPTARG"
            usage
            exit 1
        ;;

    esac
done

#Check if user has passed all required arguments
if [ -z $SCRATCH_DIR ]; then
    echo "***ERROR | SBE | signHashList : Scratch directory path not set. Please supply the -s option."
    usage
    exit 1
fi

if [ -z $HASH_LIST ]; then
    echo "***ERROR | SBE | signHashList : Hash List path not set. Please supply the -i option."
    usage
    exit 1
fi

if [ -z $COMPONENT_ID ]; then
    echo "***INFO | SBE | signHashList : Component ID not entered. Please supply the -c option."
    usage
    exit 1
fi

if [ -z $SECURE_HDR_PATH ]; then
    echo "***INFO | SBE | signHashList : Secure Header output path not entered. Please supply the -c option."
    usage
    exit 1
fi

SIGNING_DIR=
DEV_KEY_DIR=
SIGNTOOL_ARGS=

# Determine if our path setup has been provided by the environment
if [ ! -z $SIGNING_BASE_DIR ]; then
    echo "***INFO | SBE | signHashList : Fetching signing tools from provided environment"
    RH_DIR=`sed "s/^.*release \([0-9]*\).*$/rh\1/" /etc/redhat-release`
    SIGNING_DIR=$SIGNING_BASE_DIR/$RH_DIR/$SIGNING_UTILS_DIR
    DEV_KEY_DIR=${SIGNING_BASE_DIR}/sb-signing-keys

elif [ -z $SBE_IMG_DIR_OP ]; then
    echo "***INFO | SBE | signHashList : Not OP_build. Fetching keys and signing scripts from /gsa/..."
    #RH_DIR=`sed 's/^.*release \([0-9]*\)\..*$/rh\1/' /etc/redhat-release`
    #TODO: Update below paths
    if [ -n $SIGNING_RHEL_PATH ]; then
        DEV_KEY_DIR=${SIGNING_RHEL_PATH}/sb-signing-utils/test/v2_keys/
        SIGNING_DIR=${SIGNING_RHEL_PATH}/bin/
    else
        echo "***ERROR | SBE | signHashList : SIGNING_RHEL_PATH env var is not defined"
        exit 1
    fi

else
    echo "***INFO | SBE | signHashList : OP_build. Fetching keys and signing scripts from OP-Build Tree"
    DEV_KEY_DIR=${SBE_IMG_DIR_OP}/../../../host/etc/keys/
    SIGNING_DIR=${SBE_IMG_DIR_OP}/../../../host/usr/bin/
fi

# Adjust paths to pick up the signing tools
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$SIGNING_DIR
PATH=$SIGNING_DIR:$PATH


#TODO: Change to p11 env variable once op-build is enabled
# Check for signing mode passed in by environment (p10)
if [ ! -z $BR2_OPENPOWER_P10_SECUREBOOT_SIGN_MODE ]; then
    SIGNING_MODE=$BR2_OPENPOWER_P10_SECUREBOOT_SIGN_MODE

# To allow for prod signing boot loader with dev runtime can set the following env
elif [ "$COMPONENT_ID" = "BOOT_LDR" -a ! -z $ODY_BOOT_LDR_SECUREBOOT_SIGN_MODE ]; then
    SIGNING_MODE=$ODY_BOOT_LDR_SECUREBOOT_SIGN_MODE

#Check if user has passed signing mode
elif [ -z $SIGNING_MODE ]; then
    SIGNING_MODE="Development"
    echo "***INFO | SBE | signHashList : Defaulting signing mode to $SIGNING_MODE "
fi

#Set flag basis Development or production mode.
if [ "$SIGNING_MODE" = "Development" ]; then
    if [ "$COMPONENT_ID" = "BOOT_LDR" ]; then
        echo "***INFO | SBE | signHashList : Development Mode Signing."
        echo "***INFO | SBE | signHashList : Signing Boot Loader Hash List."
        SIGNTOOL_ARGS="$SIGNTOOL_ARGS --mode development --flags 0x40080000 \
                    --hwKeyA ${DEV_KEY_DIR}/boot_hw_key_a.key  \
                    --hwKeyD ${DEV_KEY_DIR}/boot_hw_key_d.key  \
                    --swKeyP ${DEV_KEY_DIR}/boot_sw_key_p.key  \
                    --swKeyS ${DEV_KEY_DIR}/boot_sw_key_s.key  "
    fi

    if [ "$COMPONENT_ID" = "RUN_TIME" ]; then
        echo "***INFO | SBE | signHashList : Development Mode Signing."
        echo "***INFO | SBE | signHashList : Signing Run Time Hash List."
        SIGNTOOL_ARGS="$SIGNTOOL_ARGS --mode development --flags 0x40080000 \
                    --hwKeyA ${DEV_KEY_DIR}/runtime_hw_key_a.key  \
                    --hwKeyD ${DEV_KEY_DIR}/runtime_hw_key_d.key  \
                    --swKeyP ${DEV_KEY_DIR}/runtime_sw_key_p.key  \
                    --swKeyS ${DEV_KEY_DIR}/runtime_sw_key_s.key  "
    fi

#TODO: Check op-build env value
elif [ "$SIGNING_MODE" = "Production" ] ; then
    echo "***INFO | SBE | signHashList : Production Mode Signing"

    if [ "$COMPONENT_ID" = "BOOT_LDR" ]; then
        if [ -z $SB_PROJECT_INI_ODY_BOOT ] || [ ! -e $SB_PROJECT_INI_ODY_BOOT ]; then
            echo "***ERROR | SBE | signHashList : Unable to locate production signing boot loader project ini file : $SB_PROJECT_INI_ODY_BOOT"
            exit 1
        fi
        if [ -z $SB_ARCHIVE_IN_ODY_BOOT ] || [ ! -e $SB_ARCHIVE_IN_ODY_BOOT ]; then
            echo "***ERROR | SBE | signHashList : Unable to locate production signing boot loader key archive : $SB_ARCHIVE_IN_ODY_BOOT"
            exit 1
        fi

        echo "***INFO | SBE | signHashList : Production Mode Signing."
        echo "***INFO | SBE | signHashList : Signing Boot Loader Hash List."
        SIGNTOOL_ARGS="$SIGNTOOL_ARGS --mode production --flags 0x40000000 \
                   --hwKeyA __getkey --hwKeyD __getkey --swKeyP __get --swKeyS __get \
                   --sign-project-config $SB_PROJECT_INI_ODY_BOOT --archiveIn $SB_ARCHIVE_IN_ODY_BOOT"
    fi
    if [ "$COMPONENT_ID" = "RUN_TIME" ]; then
        if [ -z $SB_PROJECT_INI_ODY_RUNTIME ] || [ ! -e $SB_PROJECT_INI_ODY_RUNTIME ]; then
            echo "***ERROR | SBE | signHashList : Unable to locate production signing runtime project ini file : $SB_PROJECT_INI_ODY_RUNTIME"
            exit 1
        fi
        if [ -z $SB_ARCHIVE_IN_ODY_RUNTIME ] || [ ! -e $SB_ARCHIVE_IN_ODY_RUNTIME ]; then
            echo "***ERROR | SBE | signHashList : Unable to locate production signing runtime key archive : $SB_ARCHIVE_IN_ODY_RUNTIME"
            exit 1
        fi

        echo "***INFO | SBE | signHashList : Production Mode Signing."
        echo "***INFO | SBE | signHashList : Signing Run Time Hash List."
        SIGNTOOL_ARGS="$SIGNTOOL_ARGS --mode production --flags 0x40000000 \
                   --hwKeyA __getkey --hwKeyD __getkey --swKeyP __get --swKeyS __get \
                   --sign-project-config $SB_PROJECT_INI_ODY_RUNTIME --archiveIn $SB_ARCHIVE_IN_ODY_RUNTIME"
    fi

    # Need path to SF client to access signing server
    PATH=$SIGNING_DIR/../sb-signing-framework/sb-signing-framework/src/client:$PATH

else
    echo "***ERROR | SBE | signHashList : Invalid signing mode option: $SIGNING_MODE. Enter correct -f option"
    usage
    exit 1
fi

# Do we need to set the device ECID into the FW header
if [ ! -z $SB_ODY_SECUREBOOT_ECID ]; then
    SIGNTOOL_ARGS="$SIGNTOOL_ARGS --fw-ecid $SB_ODY_SECUREBOOT_ECID"
fi

#Determine secure version setting
if [ -z $SV ]; then
    # Build process can pass in the secure version through the environment
    if [ ! -z $BR2_OPENPOWER_SIGNED_SECURITY_VERSION ]; then
        SV=$BR2_OPENPOWER_SIGNED_SECURITY_VERSION
        echo "***INFO | SBE | signHashList : SV(Secure Version) passed via " \
             "BR2_OPENPOWER_SIGNED_SECURITY_VERSION as $SV"

    # To allow for boot loader signing with a different SV you can set the following env
    elif [ "$COMPONENT_ID" = "BOOT_LDR" -a ! -z $ODY_BOOT_LDR_SECURITY_VERSION ]; then
        SV=$ODY_BOOT_LDR_SECURITY_VERSION
        echo "***INFO | SBE | signHashList : SV(Secure Version) passed via " \
             "ODY_BOOT_LDR_SECURITY_VERSION as $SV for boot loader"

    else
        SV=0
        echo "***INFO | SBE | signHashList : SV(Secure Version) not entered. Defaulting to $SV"
    fi
else
    echo "***INFO | SBE | signHashList : SV( Secure Version) entered: $SV"
fi

# Do some sanity checks on things we expect the script to consume
check_path ${DEV_KEY_DIR}/boot_hw_key_a.key
check_path ${DEV_KEY_DIR}/boot_hw_key_d.key
check_path ${DEV_KEY_DIR}/boot_sw_key_p.key
check_path ${DEV_KEY_DIR}/boot_sw_key_s.key
check_path ${DEV_KEY_DIR}/runtime_hw_key_a.key
check_path ${DEV_KEY_DIR}/runtime_hw_key_d.key
check_path ${DEV_KEY_DIR}/runtime_sw_key_p.key
check_path ${DEV_KEY_DIR}/runtime_sw_key_s.key
check_path ${HASH_LIST}
check_path ${SIGNING_DIR}/crtSignedContainer.sh

#Create the scratch dir
mkdir -p ${SCRATCH_DIR}

printf "\nSign Hash List\n"

# Sign the Hash List
CMD="$SIGNING_DIR/crtSignedContainer.sh --scratchDir ${SCRATCH_DIR} $SIGNTOOL_ARGS \
    --sign-project-FW-token ${COMPONENT_ID} --protectedPayload ${HASH_LIST} \
    --contrHdrOut ${SECURE_HDR_PATH}/secure.hdr \
    --security-version $SV --validate -V 2"
echo "Sign Hash List : $CMD"
$CMD

echo "Hash List Signed Successfully"
echo " "

#Generate Runtime image HW keys hash and MSV
if [ "$COMPONENT_ID" = "RUN_TIME" ]; then
    #Hash of the HW keys. Fetch the value from any of the secure container which is created.
    #We need to filter out the HW keys from the print container output and convert the output to .bin format
    echo "Fetch Hash of HW keys A and D..."
    print-container -w0 --imagefile ${SECURE_HDR_PATH}/secure.hdr | grep -A1 "HW keys hash" | \
    tail -1 | awk '{print $1}' | xxd -r -p > ${SECURE_HDR_PATH}/hwkeyshash.bin

    echo "Appending Runtime Image MSV into hwkeyshash.bin ..."
    echo " "
    SB_SV=`printf %02x $SV`
    SB_SV="\x${SB_SV}"
    echo -n -e $SB_SV >> ${SECURE_HDR_PATH}/hwkeyshash.bin
fi

#Lets delete the scratch dir
rm -rf $SCRATCH_DIR

exit 0
